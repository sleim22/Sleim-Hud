name: SleimRemoteHud_v1.3

slots:
    core:
        class: CoreUnit
    warpdrive:
        class: WarpDriveUnit
    shield:
        class: ShieldGeneratorUnit
    switch:
        class: ManualSwitchUnit
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    

handlers:
    unit:
        onStart:
            lua: |
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                unit.hideWidget()
                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
                Nav.axisCommandManager:setTargetGroundAltitude(4)


                brakeToggle = true --export:

                if brakeToggle then
                    isBraking = true
                    brakeInput = 1
                else
                    isBraking = false
                    brakeInput = 0
                end
                
                alarm = false
                system.showHelper(0)

                function brakeTroogle()
                    if isBraking then
                        isBraking = false
                        brakeInput = 0
                    else
                        isBraking = true
                        brakeInput = brakeInput + 1
                        local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                        if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                            local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                            if (math.abs(targetSpeed) > constants.epsilon) then
                                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                            end
                        end
                    end
                end

                function hideWarpDrive()
                    if warpdrive ~= nil then
                        if json.decode(warpdrive.getWidgetData()).destination ~= "Unknown" and json.decode(warpdrive.getWidgetData()).distance > 200000 then
                                warpdrive.showWidget()
                        else
                                warpdrive.hideWidget()
                        end
                    end
                end

                atlas = require('atlas')

                planetList = {}
                for k,nextPlanet in pairs(atlas[0]) do
                    if nextPlanet.type[1]=="Planet" then
                        planetList[#planetList+1]=nextPlanet
                        --system.print(nextPlanet.name[1])
                    end
                end

                function newGetClosestPipe(wp)
                    local pipeDistance
                    nearestDistance = nil
                    local nearestPipePlanet = nil
                    local pipeOriginPlanet = nil

                    for i=1,#planetList,1 do
                        for k=#planetList,i+1,-1 do
                            originPlanet = planetList[i]
                            nextPlanet = planetList[k]
                            local distance = getPipeDistance(vec3(originPlanet.center), vec3(nextPlanet.center),wp)
                            if (nearestDistance == nil or distance < nearestDistance) then
                                nearestPipePlanet = nextPlanet
                                nearestDistance = distance
                                pipeOriginPlanet = originPlanet
                            end
                            --system.print(planetList[i].name[1].."-"..planetList[k].name[1])
                        end
                    end
                    pipeDistance = getDistanceDisplayString(nearestDistance)
                    return pipeOriginPlanet.name[1],nearestPipePlanet.name[1],pipeDistance
                end

                function round(num, numDecimalPlaces)
                  local mult = 10^(numDecimalPlaces or 0)
                  return math.floor(num * mult + 0.5) / mult
                end


                function getDistanceDisplayString(distance) 
                    local su = distance > 100000       
                    if su then
                        -- Convert to SU
                        return round(distance / 1000 / 200, 2).."SU"
                    elseif distance < 1000 then
                        return round(distance, 2).."M"
                    else
                        -- Convert to KM
                        return round(distance / 1000, 2).."KM"
                    end
                end


                function getCurrentBody()
                    local coordinates = construct.getWorldPosition()
                    local minDistance2, body
                    local coord = vec3(coordinates)
                    for i, v in pairs(atlas[0]) do
                        local distance2 = (vec3(v.center) - coord):len2()
                        if (not body or distance2 < minDistance2) then -- Never return space.  
                            body = v
                            minDistance2 = distance2
                        end
                    end
                    return body
                end

                function getPipeDistance(origCenter, destCenter,pos) 
                    local pipeDistance
                    local worldPos = vec3(pos)
                    local pipe = (destCenter - origCenter):normalize()
                    local r = (worldPos -origCenter):dot(pipe) / pipe:dot(pipe)

                    if r <= 0. then
                        pipeDistance = (worldPos-origCenter):len()
                                return pipeDistance
                    elseif r >= (destCenter - origCenter):len() then
                        pipeDistance =(worldPos-destCenter):len()
                               return pipeDistance
                    else
                        local L = origCenter + (r * pipe)
                        pipeDistance =  (L - worldPos):len()
                        return pipeDistance
                    end        
                end

                function updatePipeInfo()
                    currentPos = construct.getWorldPosition()
                    local notPvPZone = construct.isInPvPZone == 0
                    local pvpDist = construct.getDistanceToSafeZone()
                    if pvpDist < 0 then pvpDist = pvpDist * (-1)end
                        
                    local o,p,d = newGetClosestPipe(currentPos)
                    return o,p,d,notPvPZone,pvpDist
                end
                function drawPipeInfo()
                                    local zone = ""
                                    local originPlanet,pipePlanet,pipeDist,notPvPZone,pvpDist=updatePipeInfo()
                                    if notPvPZone then
                                        zone = "PvP"
                                    else
                                        zone = "Safe"
                                    end
                                    pvpDist = getDistanceDisplayString(pvpDist)
                                    pipeInfoHtml = [[
                                    <style>
                                        .pipeInfo{
                                            position: fixed;
                                            top: 10px;
                                            left: 50%;
                                            transform: translateX(-50%);
                                            text-align: center;
                                            margin-bottom: 20px;
                                        }
                                    </style>
                                    <div class="pipeInfo">
                                        <h1>]]..originPlanet.." - "..pipePlanet..[[: ]]..pipeDist..[[</h1>
                                        <h2>]]..zone..[[ Zone in: ]]..pvpDist..[[<h2>
                                    </div>
                                    ]]
                                end

                function alarmBorder()
                    local alarm = [[
                   <style>
                   .blood {
                    width:100%;
                    height:100%;
                    box-shadow: 0 0 0px 0px red inset;
                    animation:blinking 0.3s 1;
                }

                                    @keyframes blinking{
                                    0%{   box-shadow: 0 0 0px 0px red inset;  }
                                    100%{  box-shadow: 0 0 200px 10px red inset;   }
                                    }
                }
                </style>
                <html class="blood"></html>]]
                system.setScreen(alarm)
                end
                function drawFuelInfo()
                    local fuelCSS=[[<style>
                    .fuelInfo {
                        position: fixed;
                        bottom: 40px;
                        left: 28%;
                        witdh: 200px;
                    }
                    .fuel-bar {
                        text-align: center;
                        background: #142027;
                        color: white;
                        font-family: "Lucida" Grande, sans-serif;
                        font-size: 10px;
                        border-radius: 5vh;
                        border: 1px solid;
                        border-color: #098dfe;
                    }
                    .barFullness {
                        padding: 5px;
                        border-radius: 5vh;
                        height: 95%;
                        position: center;
                        text-align: left;
                    }
                    </style>]]

                    function addFuelTank(tank,i)
                        local color = "green"
                        local percent = json.decode(tank.getWidgetData()).percentage
                         if percent == nil then 
                                            percent = 0 
                                            color = "red"
                                        elseif percent < 15 then
                                            color = "red" 
                                        elseif percent < 50 then
                                            color = "orange"
                                        end
                        return [[
                       <tr><td style="width:200px"><div class="fuel-bar">
                            <div class="barFullness" style="width: ]]..percent..[[%;
                        background:]]..color..[[;">]]..percent..[[%</div>
                        </div></td></tr>
                    ]]
                    end
                    
                    fuelHtml = fuelCSS..[[<table class="fuelInfo">
                        ]]
                    if spacefueltank_size > 0 then
                            fuelHtml = fuelHtml..[[<tr>
                            <th>Space</th>
                        </tr>]]
                    end
                    for i=1,#spacefueltank do
                        
                        fuelHtml = fuelHtml..addFuelTank(spacefueltank[i],i)
                    end
                    if atmofueltank_size > 0 then
                            fuelHtml = fuelHtml..[[<tr>
                            <th>Atmo</th>
                        </tr>]]
                    end
                    
                    for i=1,#atmofueltank do
                        fuelHtml = fuelHtml..addFuelTank(atmofueltank[i],i)
                    end

                    if rocketfueltank_size > 0 then
                            fuelHtml = fuelHtml..[[<tr>
                            <th>Rocket</th>
                        </tr>]]
                    end
                    
                    for i=1,#rocketfueltank do
                        fuelHtml = fuelHtml..addFuelTank(rocketfueltank[i],i)
                    end
                    fuelHtml = fuelHtml.."</table></div>"
                end

                function brakeHud()
                    if isBraking then
                    brakeHtml = [[
                        <style>
                        .brake{
                            position: fixed;
                            left: 50%;
                            bottom: 25%;
                            transform: translateX(-50%); 
                            text-align: center;
                            color: red;
                            text-shadow: 2px 2px 2px black;
                        }
                        </style>
                        <h1><div class="brake">Brake Engaged</div></h1>
                    ]]
                    else
                        brakeHtml = ""
                    end
                end
                function speedInfo()
                                    local throttle = math.floor(unit.getThrottle())
                                    local speed = math.floor(vec3(construct.getWorldVelocity()):len() * 3.6)
                                    local accel = math.floor((vec3(construct.getWorldAcceleration()):len()/9.80665)*10)/10
                                    local maxSpeed = math.floor(construct.getMaxSpeed()*3.6)
                                    local c = 100000000 / 3600
                                    local m0 = construct.getMass()
                                    local v0 = vec3(construct.getWorldVelocity())
                                    local controllerData = json.decode(unit.getWidgetData())
                                    local maxBrakeThrust = controllerData.maxBrake
                                    local time = 0.0
                                    dis = 0.0
                                    local v = v0:len()
                                    while v>1.0 do
                                      time = time + 1
                                      local m = m0 / (math.sqrt(1 - (v * v) / (c * c)))
                                      local a = maxBrakeThrust / m
                                      if v > a then
                                        v = v - a --*1 sec
                                        dis = dis + v + a / 2.0
                                      elseif a ~= 0 then
                                        local t = v/a
                                        dis = dis + v * t + a*t*t/2
                                        v = v - a
                                      end
                                    end
                                    local resString = ""
                                    if dis > 100000 then
                                      resString = resString..string.format(math.floor((dis/200000) * 10)/10)
                                      brakeText = "SU"  
                                    elseif dis > 1000 then
                                      resString = resString..string.format(math.floor((dis/1000)*10)/10)
                                      brakeText = "KM"  
                                    else
                                      resString = resString..string.format(math.floor(dis))
                                      brakeText = "M"  
                                    end

                                    speedHtml = [[
                                        <style>
                                            h1,h6{
                                            color: #80ffff;
                                            }
                                        table.speed{
                                            position: fixed;
                                            table-layout: fixed;
                                            left: 60%;
                                            bottom: 35%;
                                            border-spacing: 0 10px;
                                            border-collapse: separate;
                                            }
                                        table.speed td{
                                            width: 110px;
                                        }          
                                        </style>
                                            <table class="speed">
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..throttle..[[</h1></td>
                                                    <td>%</td>
                                                </tr>
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..speed..[[</h1></td>
                                                    <td>km/h <h6>(max ]]..maxSpeed..[[)</h6></td>
                                                </tr>
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..accel..[[</h1></td>
                                                    <td>g</td>
                                                </tr>
                                                <tr>
                                                    <td style="text-align: right;"><h1>]]..resString..[[</h1></td>
                                                    <td>]]..brakeText..[[ Brake-Dist</td>
                                                </tr>
                                            </table>

                                    ]]
                                end
                
                counter = 1
                dpmTable = {}
                dps = "Calculating"
                ttZ = 0
                ttZString = "Calculating"
                calculating = false
                lastShield = shield.getShieldHitpoints()
                adjustShield = false
                autoAdjustShield = false --export: NOT RECOMMENDED! Will audo adjust every minute based on current stress 
                shieldDownColor = ""
                function enemyDPS()
                    local incDmg = 0
                    local newShield = shield.getShieldHitpoints()
                    local diff = lastShield - newShield
                    dpmTable[counter] = diff
                    counter = counter +1
                    lastShield = newShield
                    local dpmTableLenght = #dpmTable
                    for i=1,dpmTableLenght do
                        incDmg = incDmg + dpmTable[i]
                    end
                    
                    if counter > 60 then
                        adjustShield = true
                        counter = 1
                    end
                    if autoAdjustShield then
                        autoAdjust()
                    end
                    if dpmTableLenght > 10 then
                        dps = incDmg/dpmTableLenght
                        if counter%5 == 0 then
                            ttZ = newShield/dps
                            if ttZ < 60 then
                                shieldDownColor = "red"
                            elseif ttZ < 180 then
                                shieldDownColor = "orange"
                            end
                            ttZString = "~"..seconds_to_clock(ttZ) 
                        elseif ttZ > 0 then
                            ttZ = ttZ - 1
                            ttZString = "~"..seconds_to_clock(ttZ) 
                        end
                        
                        dps = round(dps/1000,2).."k"                       
                    end
                    if incDmg < 1 and dpmTableLenght == 60 then
                        unit.stopTimer("dps")
                        dpmTable = {}
                        counter = 1
                        dps = "Calculating"
                        ttZ = 0
                        ttZString = "Calculating"
                        calculating = false
                    end
                end

                function autoAdjust()
                    if adjustShield then
                        adjustShield = false
                        local sRR = shield.getStressRatioRaw()
                        local tot = 0.5999
                        if sRR[1] == 0.0 and sRR[2] == 0.0 and sRR[3] == 0.0 and sRR[4] == 0.0 then return end
                        local setResist = shield.setResistances((tot*sRR[1]),(tot*sRR[2]),(tot*sRR[3]),(tot*sRR[4]))
                    end
                end

                function drawEnemyDPS()
                    local resistances = shield.getResistances()
                    local amRes = math.ceil(10+resistances[1]*100)
                    local elRes = math.ceil(10+resistances[2]*100)
                    local kiRes = math.ceil(10+resistances[3]*100)
                    local thRes = math.ceil(10+resistances[4]*100)
                    local resCd = math.floor(shield.getResistancesCooldown())
                    local ventCd = math.floor(shield.getVentingCooldown())

                    local sRR = shield.getStressRatioRaw()
                    function stressColor(stress)
                        if stress > 55 then
                            return "red"
                        elseif stress > 0 then
                            return "orange"
                        else
                            return ""
                        end
                    end
                    local amStress = math.floor(sRR[1]*100)
                    local elStress = math.floor(sRR[2]*100)
                    local kiStress = math.floor(sRR[3]*100)
                    local thStress = math.floor(sRR[4]*100)

                    if (calculating and shield.isActive()==1) or shield.isVenting()==1 or ventCd > 0 then
                    enemyDPSHtml = [[
                    <style>
                        .enemyDPS{
                            position: fixed;
                            left: 25%;
                            bottom: 35%;
                        }
                        table.cd{
                            table-layout: fixed;
                            text-align: left;
                        }
                        table.resTable{
                            table-layout: fixed;
                            text-align: center;
                        }
                        table.resTable th {
                            width: 33% ;
                        } 
                    </style>
                    <div class="enemyDPS">
                        <h3>Enemy-DPS: ]]..dps..[[</h3>
                        <h3 style="color:]]..shieldDownColor..[[">Shield Down in: ]]..ttZString..[[</h3>
                        <table class="cd">
                            <tr>
                                <th>Vent-CD: ]]..ventCd..[[s</th>
                                <th>Res-CD: ]]..resCd..[[s</th>
                            </tr>
                        </table>
                        <table class="resTable">
                            <tr>
                                <th>Type</th>
                                <th>Res</th>
                                <th>Stress</th>
                            </tr>
                            <tr style="color:]]..stressColor(amStress)..[[">
                                <td>AM</td>
                                <td>]]..amRes..[[%</td>
                                <td>]]..amStress..[[%</td>
                            </tr>
                            <tr style="color:]]..stressColor(elStress)..[[">
                                <td>EL</td>
                                <td>]]..elRes..[[%</td>
                                <td>]]..elStress..[[%</td>
                            </tr>
                            <tr style="color:]]..stressColor(kiStress)..[[">
                                <td>KI</td>
                                <td>]]..kiRes..[[%</td>
                                <td>]]..kiStress..[[%</td>
                            </tr>
                            <tr style="color:]]..stressColor(thStress)..[[">
                                <td>TH</td>
                                <td>]]..thRes..[[%</td>
                               <td>]]..thStress..[[%</td>
                            </tr>
                        </table>
                    </div>
                    ]]
                    else
                        enemyDPSHtml = ""
                    end
                end

                function seconds_to_clock(time_amount)
                    local start_seconds = time_amount
                    local start_minutes = math.modf(start_seconds/60)
                    local seconds = start_seconds - start_minutes*60
                    local start_hours = math.modf(start_minutes/60)
                    local minutes = start_minutes - start_hours*60
                    local start_days = math.modf(start_hours/24)
                    local hours = start_hours - start_days*24
                    if hours > 0 then
                    local wrapped_time = {h=hours, m=minutes, s=seconds}
                    return string.format('%02.f:%02.f:%02.f', wrapped_time.h, wrapped_time.m, wrapped_time.s)
                    else
                        local wrapped_time = {m=minutes, s=seconds}
                        return string.format('%02.f:%02.f', wrapped_time.m, wrapped_time.s)
                    end
                end
                shieldMax = shield.getMaxShieldHitpoints()
                venting = ""
                stressBarHeight = "5"
                function drawShield()
                    shieldHp = shield.getShieldHitpoints()
                    shieldPercent = shieldHp/shieldMax*100
                    if shieldPercent == 100 then shieldPercent = "100"
                    else
                    shieldPercent = string.format('%0.2f',shieldPercent)
                    end    
                    coreStressPercent = string.format('%0.2f',core.getCoreStressRatio()*100)
                    local shieldHealthBar= [[
                    <style>
                    .health-bar {
                        position: fixed;
                        width: 13em; 
                        padding: 1vh; 
                        bottom: 5vh;
                        left: 50%;
                        transform: translateX(-50%);
                        text-align: center;
                        background: #142027;
                        opacity: 0.8;
                        color: white;
                        font-family: "Lucida" Grande, sans-serif;
                        font-size: 1.5em;
                        border-radius: 5vh;
                        border: 0.2vh solid;
                        border-color: #098dfe;
                    }
                    .bar {
                        padding: 5px;
                        border-radius: 5vh;
                        background: #09c3fe;
                        opacity: 0.8;
                        width: ]]..shieldPercent..[[%;
                        height: 40px;
                        position: relative;
                    }


                    </style>
                    <html>
                        <div class="health-bar">
                            <div class="bar">]]..venting..shieldPercent..[[%</div>
                        </div>
                    </html>
                    ]]
                    local coreStressBar= [[
                    <style>
                    .stress-health-bar {
                        position: fixed;
                        width: 13em; 
                        padding: 1vh; 
                        bottom:]]..stressBarHeight..[[vh;
                        left: 50%;
                        transform: translateX(-50%);
                        text-align: center;
                        background: #142027;
                        opacity: 0.8;
                        color: white;
                        font-family: "Lucida" Grande, sans-serif;
                        font-size: 1.5em;
                        border-radius: 5vh;
                        border: 0.2vh solid;
                        border-color: #a00000;
                    }
                    .stress-bar {
                        padding: 5px;
                        border-radius: 5vh;
                        background: #ff0000;
                        opacity: 0.8;  
                        width: ]]..coreStressPercent..[[%;
                        height: 40px;
                        position: relative;
                    }


                    </style>
                    <html>
                        <div class="stress-health-bar">
                            <div class="stress-bar">]]..coreStressPercent..[[%</div>
                        </div>
                    </html>
                    ]]
                    if shield.isVenting() == 1 then
                        stressBarHeight = "15"
                        venting = "Venting "
                        healthHtml = coreStressBar..shieldHealthBar
                    elseif shield.isActive() == 0 or shield.getShieldHitpoints() == 0 then
                        stressBarHeight = "5"
                        healthHtml = coreStressBar 
                    else
                        stressBarHeight = "5"
                        venting = ""
                        healthHtml = shieldHealthBar
                    end
                end

                function combineHudElements()
                    drawFuelInfo()
                    brakeHud()
                    speedInfo()
                    drawPipeInfo()
                    drawEnemyDPS()
                    drawShield()
                    system.setScreen(fuelHtml..brakeHtml..speedHtml..pipeInfoHtml..enemyDPSHtml..healthHtml)
                end

                unit.setTimer("hud",0.1)
                system.showScreen(1)
                if switch_1 ~= nil then switch_1.activate() end
        stop:
            lua: |
                if switch_1 ~= nil then switch_1.deactivate() end
        tick:
            args: ["hud"]
            lua: |
                combineHudElements()
                hideWarpDrive()
        tick:
            args: ["dps"]
            lua: |
                enemyDPS()
    shield:
        absorbed(hitpoints,rawHitpoints):
            lua: |
                if not calculating then
                    calculating = true
                    unit.setTimer("dps",1)
                end
        venting(active,restoredHitpoints):
            lua: |
                lastShield = shield.getShieldHitpoints()               
        
    system:
        flush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')

        onUpdate:
            lua: Nav:update()

        actionStart:
            args: [option1]
            lua: |
                shield.toggle()
        actionStart:
            args: [option2]
            lua: |
                if shield.isVenting() == 0 and shield.getShieldHitpoints() < shield.getMaxShieldHitpoints() then
                    local started = shield.startVenting()
                    if started == 1 then
                        unit.stopTimer("dps")
                        dpmTable = {}
                        counter = 1
                        dps = "Calculating"
                        ttZ = 0
                        ttZString = "Calculating"
                        calculating = false
                    end
                else
                    shield.stopVenting()
                end

        actionStart:
            args: [gear]
            lua: |
                gearExtended = not gearExtended
                if gearExtended then
                    Nav.control.extendLandingGears()
                else
                    Nav.control.retractLandingGears()
                end

        actionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        actionStart:
            args: [forward]
            lua: pitchInput = pitchInput - 1
        actionStop:
            args: [forward]
            lua: pitchInput = pitchInput + 1
        actionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        actionStop:
            args: [backward]
            lua: pitchInput = pitchInput - 1
        actionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        actionStop:
            args: [left]
            lua: rollInput = rollInput + 1
        actionStart:
            args: [right]
            lua: rollInput = rollInput + 1
        actionStop:
            args: [right]
            lua: rollInput = rollInput - 1

        actionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        actionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        actionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        actionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        actionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        actionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        actionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        actionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        actionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        actionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        actionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        actionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        actionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        actionStop:
            args: [yawright]
            lua: yawInput = yawInput + 1
        actionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        actionStop:
            args: [yawleft]
            lua: yawInput = yawInput - 1
        actionStart:
            args: [brake]
            lua: |
                if brakeToggle then brakeTroogle() else 
                    brakeInput = 1 
                    isBraking = true
                end
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStop:
            args: [brake]
            lua: |
                if not brakeToggle then
                    brakeInput = 0 
                    isBraking = false
                end

        actionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        actionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        actionStart:
            args: [stopengines]
            lua: |
                if unit.getThrottle() > 0 then
                    Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                else
                    Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
                end
        actionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        actionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        actionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        actionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        actionStart:
            args: [antigravity]
            lua: if antigrav ~= nil then antigrav.toggle() end