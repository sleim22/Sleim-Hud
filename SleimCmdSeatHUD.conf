name: SleimCmdHud_v1.11.1

slots:
    core:
        class: CoreUnit
    warpdrive:
        class: WarpDriveUnit
    shield:
        class: ShieldGeneratorUnit
    weapon:
        class: WeaponUnit
        select: manual
    radar:
        class: RadarPVPUnit
        select: manual
    transponder:
        class: TransponderUnit
    switch:
        class: ManualSwitchUnit
        select: manual
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    

handlers:
    unit:
        onStart:
            lua: |
                showWeapons = true --export: Shows Weapon Widgets in 3rd person
                showShield = true --export: shows Shield Status
                showAllies = true --export: adds info about allies
                showThreats = true --export: adds info about Threats
                printSZContacts = false --export: print new Contacs in Safezone, default off
                printLocationOnContact = true --export: print own location on new target
                showTime = true --export: Shows Time when new Targets enter radar range or leave
                maxAllies = 10 --export: max Amount for detailed info about Allies, reduce if overlapping with threat info
                tempRadarTime = 200 --export: temporary Radar time in seconds until it gets destroyed
                printHitAndMiss = true --export:
                probil = 0
                targetSpeed = 0
                oldSpeed = 0
                targetDistance = 0
                oldTargetDistance = 0
                targetName = "TargetInfo"
                speedChangeIcon = ""
                distanceChangeIcon = ""
                maxCoreStress = core.getMaxCoreStress()
                venting = ""
                stressBarHeight = "5"
                newRadarContacts = {}
                newRadarCounter = 0
                newTargetId = 0
                healthHtml = ""
                alliesHtml = ""
                threatsHtml = ""
                html = ""
                allies = {}
                threats = {}
                zone = construct.isInPvPZone()
                pitchInput = 0
                rollInput = 0
                yawInput = 0
                drift = false
                pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                yawSpeedFactor = 1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
                screenHeight = system.getScreenHeight()
                screenWidth = system.getScreenWidth()
                unit.hideWidget()
                Nav = Navigator.new(system, core, unit)
                Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, { 1000, 5000, 10000, 20000, 30000 })
                Nav.axisCommandManager:setTargetGroundAltitude(4)


                brakeToggle = true --export:

                if brakeToggle then
                    isBraking = true
                    brakeInput = 1
                else
                    isBraking = false
                    brakeInput = 0
                end

                alarm = false
                system.showHelper(0)

                function brakeTroogle()
                    if isBraking then
                        isBraking = false
                        brakeInput = 0
                    else
                        isBraking = true
                        brakeInput = brakeInput + 1
                        local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                        if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                            local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                            if (math.abs(targetSpeed) > constants.epsilon) then
                                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -utils.sign(targetSpeed))
                            end
                        end
                    end
                end

                function hideWarpDrive()
                    if warpdrive ~= nil then
                        if warpdrive.getStatus() ~= 11 or warpdrive.getStatus() ~= 7 then
                            warpdrive.showWidget()
                        else
                            warpdrive.hideWidget()
                        end
                    end
                end

                atlas = require('atlas')

                planetList = {}
                for k, nextPlanet in pairs(atlas[0]) do
                    if nextPlanet.type[1] == "Planet" then
                        planetList[#planetList + 1] = nextPlanet
                        --system.print(nextPlanet.name[1])
                    end
                end

                function newGetClosestPipe(wp)
                    local pipeDistance
                    nearestDistance = nil
                    local nearestPipePlanet = nil
                    local pipeOriginPlanet = nil

                    for i = 1, #planetList, 1 do
                        for k = #planetList, i + 1, -1 do
                            originPlanet = planetList[i]
                            nextPlanet = planetList[k]
                            local distance = getPipeDistance(vec3(originPlanet.center), vec3(nextPlanet.center), wp)
                            if (nearestDistance == nil or distance < nearestDistance) then
                                nearestPipePlanet = nextPlanet
                                nearestDistance = distance
                                pipeOriginPlanet = originPlanet
                            end
                            --system.print(planetList[i].name[1].."-"..planetList[k].name[1])
                        end
                    end
                    pipeDistance = getDistanceDisplayString(nearestDistance)
                    return pipeOriginPlanet.name[1], nearestPipePlanet.name[1], pipeDistance
                end

                function round(num, numDecimalPlaces)
                    local mult = 10 ^ (numDecimalPlaces or 0)
                    return math.floor(num * mult + 0.5) / mult
                end

                function getDistanceDisplayString(distance)
                    local su = distance > 100000
                    if su then
                        -- Convert to SU
                        return round(distance / 1000 / 200, 2) .. "SU"
                    elseif distance < 1000 then
                        return round(distance, 2) .. "M"
                    else
                        -- Convert to KM
                        return round(distance / 1000, 2) .. "KM"
                    end
                end

                function getCurrentBody()
                    local coordinates = construct.getWorldPosition()
                    local minDistance2, body
                    local coord = vec3(coordinates)
                    for i, v in pairs(atlas[0]) do
                        local distance2 = (vec3(v.center) - coord):len2()
                        if (not body or distance2 < minDistance2) then -- Never return space.
                            body = v
                            minDistance2 = distance2
                        end
                    end
                    return body
                end

                function getPipeDistance(origCenter, destCenter, pos)
                    local pipeDistance
                    local worldPos = vec3(pos)
                    local pipe = (destCenter - origCenter):normalize()
                    local r = (worldPos - origCenter):dot(pipe) / pipe:dot(pipe)

                    if r <= 0. then
                        pipeDistance = (worldPos - origCenter):len()
                        return pipeDistance
                    elseif r >= (destCenter - origCenter):len() then
                        pipeDistance = (worldPos - destCenter):len()
                        return pipeDistance
                    else
                        local L = origCenter + (r * pipe)
                        pipeDistance = (L - worldPos):len()
                        return pipeDistance
                    end
                end

                function updatePipeInfo()
                    currentPos = construct.getWorldPosition()
                    local notPvPZone = construct.isInPvPZone() == 0
                    local pvpDist = construct.getDistanceToSafeZone()
                    if pvpDist < 0 then pvpDist = pvpDist * (-1) end

                    local o, p, d = newGetClosestPipe(currentPos)
                    return o, p, d, notPvPZone, pvpDist
                end

                function drawPipeInfo()
                    local zone = ""
                    local originPlanet, pipePlanet, pipeDist, notPvPZone, pvpDist = updatePipeInfo()
                    if notPvPZone then
                        zone = "PvP"
                    else
                        zone = "Safe"
                    end
                    pvpDist = getDistanceDisplayString(pvpDist)
                    pipeInfoHtml = [[
                                                    <style>
                                                        .pipeInfo{
                                                            position: fixed;
                                                            top: 10px;
                                                            left: 50%;
                                                            transform: translateX(-50%);
                                                            text-align: center;
                                                            margin-bottom: 20px;
                                                        }
                                                    </style>
                                                    <div class="pipeInfo">
                                                        <h1>]] .. originPlanet .. " - " .. pipePlanet .. [[: ]] .. pipeDist .. [[</h1>
                                                        <h2>]] .. zone .. [[ Zone in: ]] .. pvpDist .. [[<h2>
                                                    </div>
                                                    ]]
                end

                function drawFuelInfo()
                    local fuelCSS = [[<style>
                                    .fuelInfo {
                                        position: fixed;
                                        bottom: 40px;
                                        left: 28%;
                                        witdh: 200px;
                                    }
                                    .fuel-bar {
                                        text-align: center;
                                        background: #142027;
                                        color: white;
                                        font-family: "Lucida" Grande, sans-serif;
                                        font-size: 10px;
                                        border-radius: 5vh;
                                        border: 1px solid;
                                        border-color: #098dfe;
                                    }
                                    .barFullness {
                                        padding: 5px;
                                        border-radius: 5vh;
                                        height: 95%;
                                        position: center;
                                        text-align: left;
                                    }
                                    </style>]]

                    function addFuelTank(tank, i)
                        local color = "green"
                        local percent = json.decode(tank.getWidgetData()).percentage
                        if percent == nil then
                            percent = 0
                            color = "red"
                        elseif percent < 15 then
                            color = "red"
                        elseif percent < 50 then
                            color = "orange"
                        end
                        return [[
                                    <tr><td style="width:200px"><div class="fuel-bar">
                                            <div class="barFullness" style="width: ]] .. percent .. [[%;
                                        background:]] .. color .. [[;">]] .. percent .. [[%</div>
                                        </div></td></tr>
                                    ]]
                    end

                    fuelHtml = fuelCSS .. [[<table class="fuelInfo">
                                        ]]
                    if spacefueltank_size > 0 then
                        fuelHtml = fuelHtml .. [[<tr>
                                            <th>Space</th>
                                        </tr>]]
                    end
                    for i = 1, #spacefueltank do

                        fuelHtml = fuelHtml .. addFuelTank(spacefueltank[i], i)
                    end
                    if atmofueltank_size > 0 then
                        fuelHtml = fuelHtml .. [[<tr>
                                            <th>Atmo</th>
                                        </tr>]]
                    end

                    for i = 1, #atmofueltank do
                        fuelHtml = fuelHtml .. addFuelTank(atmofueltank[i], i)
                    end

                    if rocketfueltank_size > 0 then
                        fuelHtml = fuelHtml .. [[<tr>
                                            <th>Rocket</th>
                                        </tr>]]
                    end

                    for i = 1, #rocketfueltank do
                        fuelHtml = fuelHtml .. addFuelTank(rocketfueltank[i], i)
                    end
                    fuelHtml = fuelHtml .. "</table></div>"
                end

                function brakeHud()
                    if isBraking then
                        brakeHtml = [[
                                        <style>
                                        .brake{
                                            position: fixed;
                                            left: 50%;
                                            bottom: 25%;
                                            transform: translateX(-50%); 
                                            text-align: center;
                                            color: red;
                                            text-shadow: 2px 2px 2px black;
                                        }
                                        </style>
                                        <h1><div class="brake">Brake Engaged</div></h1>
                                    ]]
                    else
                        brakeHtml = ""
                    end
                end

                function speedInfo()
                    local throttle = math.floor(unit.getThrottle())
                    local speed = math.floor(vec3(construct.getWorldVelocity()):len() * 3.6)
                    local accel = math.floor((vec3(construct.getWorldAcceleration()):len() / 9.80665) * 10) / 10
                    local maxSpeed = math.floor(construct.getMaxSpeed() * 3.6)
                    local c = 100000000 / 3600
                    local m0 = construct.getMass()
                    local v0 = vec3(construct.getWorldVelocity())
                    local maxBrakeThrust = construct.getMaxBrake()
                    local time = 0.0
                    dis = 0.0
                    local v = v0:len()
                    if maxBrakeThrust > 0 then
                        while v > 1.0 do
                            time = time + 1
                            local m = m0 / (math.sqrt(1 - (v * v) / (c * c)))
                            local a = maxBrakeThrust / m
                            if v > a then
                                v = v - a --*1 sec
                                dis = dis + v + a / 2.0
                            elseif a ~= 0 then
                                local t = v / a
                                dis = dis + v * t + a * t * t / 2
                                v = v - a
                            end
                        end
                    end
                    local resString = ""
                    if dis > 100000 then
                        resString = resString .. string.format(math.floor((dis / 200000) * 10) / 10)
                        brakeText = "SU"
                    elseif dis > 1000 then
                        resString = resString .. string.format(math.floor((dis / 1000) * 10) / 10)
                        brakeText = "KM"
                    else
                        resString = resString .. string.format(math.floor(dis))
                        brakeText = "M"
                    end

                    driftInfo = ""
                    if drift then
                        driftInfo = [[<tr>
                        <td style="text-align: center;" colspan="2"><h6>Inertia-Dampening: Off</h6></td>
                    </tr>]]
                    end
                    speedHtml = [[
                                    <style>
                                        h1,h6{
                                        color: #80ffff;
                                        }
                                    table.speed{
                                        position: fixed;
                                        table-layout: fixed;
                                        left: 60%;
                                        bottom: 35%;
                                        border-spacing: 0 10px;
                                        border-collapse: separate;
                                        }
                                    table.speed td{
                                        width: 110px;
                                    }          
                                    </style>
                                        <table class="speed">
                                            <tr>
                                                <td style="text-align: right;"><h1>]] .. throttle .. [[</h1></td>
                                                <td>%</td>
                                            </tr>
                                            <tr>
                                                <td style="text-align: right;"><h1>]] .. speed .. [[</h1></td>
                                                <td>km/h <h6>(max ]] .. maxSpeed .. [[)</h6></td>
                                            </tr>
                                            <tr>
                                                <td style="text-align: right;"><h1>]] .. accel .. [[</h1></td>
                                                <td>g</td>
                                            </tr>
                                            <tr>
                                                <td style="text-align: right;"><h1>]] .. resString .. [[</h1></td>
                                                <td>]] .. brakeText .. [[ Brake-Dist</td>
                                            </tr>]] .. driftInfo .. [[
                                        </table>]]
                end
                if shield then
                    counter = 1
                    dpmTable = {}
                    dps = "Calculating"
                    ttZ = 0
                    ttZString = "Calculating"
                    calculating = false
                    lastShield = shield.getShieldHitpoints()
                    autoAdjustShield = false --export: NOT RECOMMENDED! Will audo adjust every minute based on current stress
                    shieldDownColor = ""
                    ShieldRes = {}
                    function enemyDPS()
                        local incDmg = 0
                        local newShield = shield.getShieldHitpoints()
                        local diff = lastShield - newShield
                        dpmTable[counter] = diff
                        counter = counter + 1
                        lastShield = newShield
                        local dpmTableLenght = #dpmTable
                        for i = 1, dpmTableLenght do
                            incDmg = incDmg + dpmTable[i]
                        end
                        
                        if counter > 60 then
                            counter = 1
                        end
                        autoAdjust()
                        if dpmTableLenght > 10 then
                            dps = incDmg/dpmTableLenght
                            if counter%5 == 0 then
                                ttZ = newShield/dps
                                if ttZ < 60 then
                                    shieldDownColor = "red"
                                elseif ttZ < 180 then
                                    shieldDownColor = "orange"
                                end
                                ttZString = "~"..seconds_to_clock(ttZ) 
                            elseif ttZ > 0 then
                                ttZ = ttZ - 1
                                ttZString = "~"..seconds_to_clock(ttZ) 
                            end
                            
                            dps = round(dps/1000,2).."k"                       
                        end
                        if incDmg < 1 and dpmTableLenght == 60 then
                            unit.stopTimer("dps")
                            dpmTable = {}
                            counter = 1
                            dps = "Calculating"
                            ttZ = 0
                            ttZString = "Calculating"
                            calculating = false
                        end
                    end

                    local waitTimer = 0
                    function autoAdjust()
                        local sRR = shield.getStressRatioRaw()
                        local tot = shield.getResistancesPool()
                        local resistances = shield.getResistances()
                        local shieldCD = shield.getResistancesCooldown()
                        local diffValue = 0
                        for i = 1, 4, 1 do
                            local v = sRR[i] - resistances[i] / tot
                            diffValue = math.max(v, diffValue)
                        end
                        if diffValue > 0.6 then waitTimer = waitTimer + 1 else waitTimer = 0 end
                        if shieldCD == 0 and ((autoAdjustShield and diffValue > 0.15) or (waitTimer > 15 and diffValue > 0.6)) then
                            if sRR[1] == 0.0 and sRR[2] == 0.0 and sRR[3] == 0.0 and sRR[4] == 0.0 then return end
                            local setResist = shield.setResistances((tot * sRR[1]), (tot * sRR[2]), (tot * sRR[3]), (tot * sRR[4]))
                        end
                    end

                    function drawEnemyDPS()
                        local resistances = shield.getResistances()
                        local resCd = math.floor(shield.getResistancesCooldown())
                        local ventCd = math.floor(shield.getVentingCooldown())

                        local sRR = shield.getStressRatioRaw()

                        ShieldDisplay = {}
                        screenHeight = system.getScreenHeight()
                        screenWidth = system.getScreenWidth()
                        ShieldDisplay.startX = screenWidth * 0.17
                        ShieldDisplay.startY = screenHeight * 25 / 1080
                        ShieldDisplay.resFactorX = screenWidth / 1920
                        ShieldDisplay.resFactorY = screenHeight / 1080
                        --system.print(ShieldDisplay.resFactorX)

                        ShieldDisplay.totalWidth = 350 * ShieldDisplay.resFactorX
                        ShieldDisplay.totalHeight = 250 * ShieldDisplay.resFactorY
                        ShieldDisplay.resBarWidth = ShieldDisplay.totalWidth * 3 / 5
                        ShieldDisplay.barMargin = 25 * ShieldDisplay.resFactorY
                        ShieldDisplay.textMargin = 20 * ShieldDisplay.resFactorY
                        ShieldDisplay.barStart = 60 * ShieldDisplay.resFactorY

                        ShieldRes.maxPool = shield.getResistancesPool()

                        if not leftAltPressed then
                            ShieldRes.currentPool = shield.getResistancesRemaining()
                            ShieldRes[1] = { resistances[1], "AM", sRR[1] }
                            ShieldRes[2] = { resistances[2], "EM", sRR[2] }
                            ShieldRes[3] = { resistances[3], "KI", sRR[3] }
                            ShieldRes[4] = { resistances[4], "TH", sRR[4] }

                        end
                        ShieldDisplay.setString = "Set"
                        if resCd > 0 then
                            ShieldDisplay.setString = resCd .. " s"
                        end
                        ShieldDisplay.ventString = "Vent"
                        if ventCd > 0 then
                            ShieldDisplay.ventString = ventCd .. " sec"
                        end

                        if autoAdjustShield then
                            ShieldDisplay.autoString = "Auto"
                            ShieldDisplay.autoStringStart = 168
                        else
                            ShieldDisplay.autoString = "Manual"
                            ShieldDisplay.autoStringStart = 158
                        end

                        if (calculating and shield.isActive()) or shield.isVenting() or ventCd > 0 or leftAltPressed or resCd > 0 then
                            ShieldDisplay.HTML = [[

                                    <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;fill:white;stroke:#80ffff;font-weight:bold">

                                        <rect x="]] ..
                                ShieldDisplay.startX ..
                                [[" y="]] ..
                                ShieldDisplay.startY ..
                                [[" rx="20" ry="20" width="]] ..
                                ShieldDisplay.totalWidth ..
                                [[" height="]] .. ShieldDisplay.totalHeight .. [[" style="stroke-width:2;fill-opacity:0"/>

                                        <text x="]] ..
                                ShieldDisplay.startX + 30 ..
                                [[" y="]] .. ShieldDisplay.startY + ShieldDisplay.textMargin .. [[">Enemy DPS: ]] .. dps .. [[</text>
                                        <text x="]] ..
                                ShieldDisplay.startX + 30 ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.textMargin * 2 ..
                                [[" fill="]] .. shieldDownColor .. [[">Time till shield down: ]] .. ttZString .. [[</text>
                                            <line x1="]] ..
                                ShieldDisplay.startX + 10 ..
                                [[" y1="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barMargin * 2 ..
                                [[" x2="]] ..
                                ShieldDisplay.startX + ShieldDisplay.totalWidth - 10 ..
                                [[" y2="]] .. ShieldDisplay.startY + ShieldDisplay.barMargin * 2 .. [[" style="stroke-width:2" />
                                        
                                        <text x="]] ..
                                ShieldDisplay.startX + 30 ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barMargin * 3 ..
                                [[">Points left: ]] .. math.floor(ShieldRes.currentPool * 100) ..
                                "/" .. math.floor(ShieldRes.maxPool * 100) .. [[</text>

                                        ]]

                            for i = 1, 4, 1 do
                                ShieldDisplay.HTML = ShieldDisplay.HTML ..
                                    [[<text x="]] ..
                                    ShieldDisplay.startX + 12 ..
                                    [[" y="]] ..
                                    ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * i + 8 ..
                                    [[" font-weight:"lighter" font-size="10">]] .. ShieldRes[i][2] .. [[</text>
                                            <rect x="]] ..
                                    ShieldDisplay.startX + 30 ..
                                    [[" y="]] ..
                                    ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * i ..
                                    [[" rx="2" ry="2" width="]] ..
                                    ShieldDisplay.resBarWidth * ShieldRes[i][1] / ShieldRes.maxPool ..
                                    [[" height="10" style="stroke-width:0;fill-opacity:0.8;fill:white" />
                                            <rect x="]] ..
                                    ShieldDisplay.startX + 30 ..
                                    [[" y="]] ..
                                    ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * i ..
                                    [[" rx="2" ry="2" width="]] .. ShieldDisplay.resBarWidth ..
                                    [[" height="10" style="stroke-width:2;fill-opacity:0" />
                                            
                                            <rect x="]] ..
                                    ShieldDisplay.startX + ShieldDisplay.resBarWidth + 40 ..
                                    [[" y="]] ..
                                    ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * i ..
                                    [[" rx="2" ry="2" width="]] ..
                                    (ShieldDisplay.totalWidth - ShieldDisplay.resBarWidth - 60) * ShieldRes[i][3] ..
                                    [[" height="10" style="stroke-width:0;fill-opacity:0.8;fill:red" />
                                            <rect x="]] ..
                                    ShieldDisplay.startX + ShieldDisplay.resBarWidth + 40 ..
                                    [[" y="]] ..
                                    ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * i ..
                                    [[" rx="2" ry="2" width="]] ..
                                    (ShieldDisplay.totalWidth - ShieldDisplay.resBarWidth - 60) ..
                                    [[" height="10" style="stroke-width:2;fill-opacity:0" />
                                            
                                            ]]
                            end
                            ShieldDisplay.HTML = ShieldDisplay.HTML .. [[
                                        
                                        <rect x="]] ..
                                ShieldDisplay.startX + 30 * ShieldDisplay.resFactorX ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 5 ..
                                [[" rx="4" ry="4" width="]] ..
                                50 * ShieldDisplay.resFactorX .. [[" height="40" style="fill:yellow;stroke-width:2;fill-opacity:0" />
                                        <text x="]] ..
                                ShieldDisplay.startX + 45 * ShieldDisplay.resFactorX ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 6 ..
                                [[" style="font-weight:bold">]] .. ShieldDisplay.setString .. [[</text>
                                        
                                            <rect x="]] ..
                                ShieldDisplay.startX + 90 * ShieldDisplay.resFactorX ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 5 ..
                                [[" rx="4" ry="4" width="]] ..
                                50 * ShieldDisplay.resFactorX .. [[" height="40" style="fill:yellow;stroke-width:2;fill-opacity:0" />
                                            <text x="]] ..
                                ShieldDisplay.startX + 98 * ShieldDisplay.resFactorX ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 6 ..
                                [[" style="font-weight:bold">Reset</text>

                                <rect x="]] ..
                                ShieldDisplay.startX + 150 * ShieldDisplay.resFactorX ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 5 ..
                                [[" rx="4" ry="4" width="]] ..
                                65 * ShieldDisplay.resFactorX .. [[" height="40" style="fill:yellow;stroke-width:2;fill-opacity:0" />
                                            <text x="]] ..
                                ShieldDisplay.startX + ShieldDisplay.autoStringStart * ShieldDisplay.resFactorX ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 6 ..
                                [[" style="font-weight:bold">]] .. ShieldDisplay.autoString .. [[</text>

                                        <rect x="]] ..
                                ShieldDisplay.startX + ShieldDisplay.resBarWidth + ShieldDisplay.textMargin * 2 ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 5 ..
                                [[" rx="4" ry="4" width="]] ..
                                (ShieldDisplay.totalWidth - ShieldDisplay.resBarWidth - 60) ..
                                [[" height="40" style="fill:yellow;stroke-width:2;fill-opacity:0" />
                                        <text x="]] ..
                                ShieldDisplay.startX + ShieldDisplay.resBarWidth + ShieldDisplay.textMargin * 3 ..
                                [[" y="]] ..
                                ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 6 ..
                                [[" style="font-weight:bold">]] .. ShieldDisplay.ventString .. [[</text>
                                        
                                        </svg>]]

                        else
                            ShieldDisplay.HTML = ""
                        end
                    end
                    Max = shield.getMaxShieldHitpoints()
                    venting = ""
                    stressBarHeight = "5"
                    function drawShield()
                        shieldMax = shield.getMaxShieldHitpoints()
                        shieldHp = shield.getShieldHitpoints()
                        shieldPercent = shieldHp / shieldMax * 100
                        if shieldPercent == 100 then shieldPercent = "100"
                        else
                            shieldPercent = string.format('%0.2f', shieldPercent)
                        end
                        coreStressPercent = string.format('%0.2f', core.getCoreStressRatio() * 100)
                        local shieldHealthBar = [[
                                        <style>
                                        .health-bar {
                                            position: fixed;
                                            width: 13em; 
                                            padding: 1vh; 
                                            bottom: 5vh;
                                            left: 50%;
                                            transform: translateX(-50%);
                                            text-align: center;
                                            background: #142027;
                                            opacity: 0.8;
                                            color: white;
                                            font-family: "Lucida" Grande, sans-serif;
                                            font-size: 1.5em;
                                            border-radius: 5vh;
                                            border: 0.2vh solid;
                                            border-color: #098dfe;
                                        }
                                        .bar {
                                            padding: 5px;
                                            border-radius: 5vh;
                                            background: #09c3fe;
                                            opacity: 0.8;
                                            width: ]] .. shieldPercent .. [[%;
                                            height: 40px;
                                            position: relative;
                                        }


                                        </style>
                                        <html>
                                            <div class="health-bar">
                                                <div class="bar">]] .. venting .. shieldPercent .. [[%</div>
                                            </div>
                                        </html>
                                        ]]
                        local coreStressBar = [[
                                        <style>
                                        .stress-health-bar {
                                            position: fixed;
                                            width: 13em; 
                                            padding: 1vh; 
                                            bottom:]] .. stressBarHeight .. [[vh;
                                            left: 50%;
                                            transform: translateX(-50%);
                                            text-align: center;
                                            background: #142027;
                                            opacity: 0.8;
                                            color: white;
                                            font-family: "Lucida" Grande, sans-serif;
                                            font-size: 1.5em;
                                            border-radius: 5vh;
                                            border: 0.2vh solid;
                                            border-color: #a00000;
                                        }
                                        .stress-bar {
                                            padding: 5px;
                                            border-radius: 5vh;
                                            background: #ff0000;
                                            opacity: 0.8;  
                                            width: ]] .. coreStressPercent .. [[%;
                                            height: 40px;
                                            position: relative;
                                        }


                                        </style>
                                        <html>
                                            <div class="stress-health-bar">
                                                <div class="stress-bar">]] .. coreStressPercent .. [[%</div>
                                            </div>
                                        </html>
                                        ]]
                        if shield.isVenting() then
                            stressBarHeight = "15"
                            venting = "Venting "
                            healthHtml = coreStressBar .. shieldHealthBar
                        elseif not shield.isActive() or shield.getShieldHitpoints() == 0 then
                            stressBarHeight = "5"
                            healthHtml = coreStressBar
                        else
                            stressBarHeight = "5"
                            venting = ""
                            healthHtml = shieldHealthBar
                        end
                    end
                else
                    ShieldDisplay = {}
                    ShieldDisplay.HTML = ""
                end
                function seconds_to_clock(time_amount)
                    local start_seconds = time_amount
                    local start_minutes = math.modf(start_seconds / 60)
                    local seconds = start_seconds - start_minutes * 60
                    local start_hours = math.modf(start_minutes / 60)
                    local minutes = start_minutes - start_hours * 60
                    local start_days = math.modf(start_hours / 24)
                    local hours = start_hours - start_days * 24
                    if hours > 0 then
                        local wrapped_time = { h = hours, m = minutes, s = seconds }
                        return string.format('%02.f:%02.f:%02.f', wrapped_time.h, wrapped_time.m, wrapped_time.s)
                    else
                        local wrapped_time = { m = minutes, s = seconds }
                        return string.format('%02.f:%02.f', wrapped_time.m, wrapped_time.s)
                    end
                end

                

                planetAR = ""
                function drawPlanetsOnScreen()
                    screenHeight = system.getScreenHeight()
                    screenWidth = system.getScreenWidth()
                    if lshiftPressed then
                        planetAR = [[<svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">]]
                        for _, v in pairs(planetList) do
                            local point = vec3(v.center)
                            local distance = (point - vec3(construct.getWorldPosition())):len()
                            local planetPosOnScreen = library.getPointOnScreen({ point['x'], point['y'], point['z'] })
                            local xP = screenWidth * planetPosOnScreen[1]
                            local yP = screenHeight * planetPosOnScreen[2]
                            local deth = 12
                            local su = (distance / 200 / 1000)
                            if su < 10 then
                                deth = 250 - 800 * (distance / 1000 / 200 / 40)
                            elseif su < 40 then

                                deth = 20
                            end
                            local pipeDist = getPipeDistance(point)
                            local eta = getETA(distance, pipeDist, xP + deth, yP + deth)
                            if xP > 0 and yP > 0 then
                                planetAR = planetAR ..
                                    [[<circle cx="]] ..
                                    xP ..
                                    [[" cy="]] ..
                                    yP ..
                                    [[" r="]] .. deth .. [[" stroke="orange" stroke-width="1" style="fill-opacity:0" /><text x="]] ..
                                    xP + deth ..
                                    [[" y="]] ..
                                    yP + deth .. [[" fill="#c7dcff">]] .. v.name[1] ..
                                    " " .. getDistanceDisplayString(distance) .. [[</text>]]..eta
                            end
                        end
                        planetAR = planetAR .. "</svg>"
                    else
                        planetAR = ""
                    end
                end

                aliencores = { [1] = {
                    name = "Alpha",
                    pos = { 33946000.0000,71381990.0000,28850000.0000} 
                }, [2] = {
                    name = "Gamma",
                    pos = { -64334000.0000,55522000.0000,-14400000.0000} 
                },
                }

                alienAR = ""
                function drawAlienCores()
                    if lshiftPressed then
                        alienAR = ""
                        for _, v in pairs(aliencores) do
                            local point = vec3(v.pos)
                            local distance = (point - vec3(construct.getWorldPosition())):len()
                            local alienPosOnScreen = library.getPointOnScreen({ point['x'], point['y'], point['z'] })
                            local xP = screenWidth * alienPosOnScreen[1]
                            local yP = screenHeight * alienPosOnScreen[2]
                            if xP > 0 and yP > 0 then
                                local pipeDist = getPipeDistance(point)
                                local eta = getETA(distance, pipeDist, xP + 10, yP + 12)
                                alienAR = alienAR ..
                                    [[<div style="position: fixed;left: ]] ..
                                    xP .. [[px;top:]] .. yP .. [[px;"><svg height="30" width="15">
                                                <g>
                                                    <path style="fill:purple;" d="M8.472,0l-1.28,0.003c-2.02,0.256-3.679,1.104-4.671,2.386C1.685,3.47,1.36,4.78,1.553,6.283
                                                        c0.37,2.87,2.773,6.848,4.674,8.486c0.475,0.41,1.081,0.794,1.353,0.899c0.129,0.044,0.224,0.073,0.333,0.073
                                                        c0.11,0,0.217-0.031,0.319-0.091c1.234-0.603,2.438-1.88,3.788-4.02c0.936-1.485,2.032-3.454,2.2-5.495
                                                        C14.492,2.843,12.295,0.492,8.472,0z M8.435,0.69c3.431,0.447,5.337,2.462,5.097,5.391c-0.156,1.913-1.271,3.875-2.097,5.182
                                                        c-1.278,2.027-2.395,3.226-3.521,3.777c-0.005,0.002-0.009,0.004-0.012,0.005c-0.029-0.006-0.068-0.021-0.087-0.027
                                                        c-0.149-0.057-0.706-0.401-1.135-0.771c-1.771-1.525-4.095-5.375-4.44-8.052C2.07,4.879,2.348,3.741,3.068,2.812
                                                        c0.878-1.135,2.363-1.889,4.168-2.12L8.435,0.69z"/>
                                                    <path style="fill:purple;" d="M3.504,6.83C3.421,6.857,3.37,6.913,3.373,7.024c0.308,1.938,1.616,3.536,3.842,3.126
                                                        C7.002,8.019,5.745,6.933,3.504,6.83z"/>
                                                    <path style="fill:purple;" d="M8.778,10.215c2.196-0.125,3.61-1.379,3.776-3.319C10.321,6.727,8.55,7.923,8.778,10.215z"/>
                                                </g>
                                            </svg>]] .. v.name .. " " .. getDistanceDisplayString(distance) .. [[</div>]]
                                alienAR = alienAR .. [[<svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">]] .. eta.. [[</svg>]]
           
                            end
                        end
                    else
                        alienAR = ""
                    end
                end

                radar = radar_1
                if radar_size == 0 then
                    system.print("Connect a space radar and run config again!")
                    unit.exit()
                end
                if weapon_size == 0 then
                    system.print("No Weapons connected")
                    --unit.exit()
                end
                local kSkipCharSet = { ["O"] = true, ["Q"] = true, ["0"] = true }
                local kCharSet = {}

                local function addRangeToCharSet(a, b)
                    for i = a, b do
                        local c = string.char(i)
                        if not kSkipCharSet[c] then
                            kCharSet[#kCharSet + 1] = c
                        end
                    end
                end

                -- 0 - 9
                addRangeToCharSet(48, 57)
                -- A - Z
                addRangeToCharSet(65, 90)

                local kCharSetSize = #kCharSet

                local function getHash(x)
                    if x == nil then
                        return 0
                    end
                    x = ((x >> 16) ~ x) * 0x45d9f3b
                    x = ((x >> 16) ~ x) * 0x45d9f3b
                    x = (x >> 16) ~ x
                    if x < 0 then x = ~x end
                    return x
                end

                function getShortName(id)
                    local seed = getHash(id) % 8388593
                    local a = (seed * 653276) % 8388593
                    local b = (a * 653276) % 8388593
                    local c = (b * 653276) % 8388593
                    return kCharSet[a % kCharSetSize + 1] .. kCharSet[b % kCharSetSize + 1] .. kCharSet[c % kCharSetSize + 1]
                end

                function seconds_to_clock(time_amount)
                    local start_seconds = time_amount
                    local start_minutes = math.modf(start_seconds / 60)
                    local seconds = start_seconds - start_minutes * 60
                    local start_hours = math.modf(start_minutes / 60)
                    local minutes = start_minutes - start_hours * 60
                    local start_days = math.modf(start_hours / 24)
                    local hours = start_hours - start_days * 24
                    local wrapped_time = { h = hours, m = minutes, s = seconds }
                    if hours > 0 then
                        return string.format('%02.f:%02.f:%02.f', wrapped_time.h, wrapped_time.m, wrapped_time.s)
                    else
                        return string.format('%02.f:%02.f', wrapped_time.m, wrapped_time.s)
                    end
                end

                function WeaponWidgetCreate()
                        if type(weapon) == 'table' and #weapon > 0 then
                            local WeaponPanaelIdList = {}
                            for i = 1, #weapon do
                                if (#weapon == 6 and i == 4 or i == 1) or (#weapon < 6 and i % 2 ~= 0) then
                                table.insert(WeaponPanaelIdList, system.createWidgetPanel(''))
                                end
                                local WeaponWidgetDataId = weapon[i].getWidgetDataId()
                                local WeaponWidgetType = weapon[i].getWidgetType()
                                system.addDataToWidget(WeaponWidgetDataId, system.createWidget(WeaponPanaelIdList[#WeaponPanaelIdList], WeaponWidgetType))
                            end
                    end
                end
                if showWeapons then 
                    WeaponWidgetCreate()
                end

                function getFriendlyDetails(id)
                    owner = radar.getConstructOwnerEntity(id)
                    if owner.id and owner.isOrganization then
                        return system.getOrganization(owner.id).name
                    end
                    if owner.id and not owner.isOrganization then
                        return system.getPlayerName(owner.id)
                    end
                    return ""
                end

                function printNewRadarContacts()
                    if zone == 1 or printSZContacts then
                        local newTargetCounter = 0
                        for k, v in pairs(newRadarContacts) do
                            if newTargetCounter > 10 then
                                system.print("Didnt print all new Contacts to prevent overload!")
                                break
                            end
                            newTargetCounter = newTargetCounter + 1
                            newTargetName = "[" .. radar.getConstructCoreSize(v) ..
                                "]-" .. getShortName(v) .. "- " .. radar.getConstructName(v)
                            if showTime then
                                newTargetName = newTargetName .. ' - Time: ' .. seconds_to_clock(system.getArkTime())
                            end
                            if radar and radar.hasMatchingTransponder(v) then
                                newTargetName = newTargetName .. " - [Ally] Owner: " .. getFriendlyDetails(v)
                                if not borderActive then
                                    borderColor = "green"
                                    borderWidth = 200
                                    borderActive = true
                                    unit.setTimer("cleanBorder", 1)
                                end
                            elseif radar.isConstructAbandoned(v) then
                                newTargetName = newTargetName .. " - Abandoned"
                            else
                                system.playSound("contact.mp3")
                                if not borderActive then
                                    borderActive = true
                                    borderColor = "red"
                                    borderWidth = 200
                                    unit.setTimer("cleanBorder", 1)
                                end
                            end
                            system.print("New Target: " .. newTargetName)
                            if printLocationOnContact then
                                system.print(system.getWaypointFromPlayerPos())
                            end
                        end
                        newRadarContacts = {}
                    else
                        newRadarContacts = {}
                    end
                end

                function getMaxCorestress()
                    if maxCoreStress > 1000000 then
                        maxCoreStress = string.format('%0.3f', (maxCoreStress / 1000000)) .. "M"
                    elseif maxCoreStress > 1000 then
                        maxCoreStress = string.format('%0.2f', (maxCoreStress / 1000)) .. "k"
                    end
                    system.print("Max Core Stress: " .. maxCoreStress)
                end

                requiredTargets = {}
                function readRequiredValues()
                    if autoTargets then
                        requiredTargets = {}
                        local targets = require("Targets")
                        for _, v in pairs(targets) do
                            local id = v.shortid[1]
                            if id ~= targetCode then
                                requiredTargets[#requiredTargets + 1] = v.shortid[1]
                            end
                        end
                        package.loaded['Targets'] = nil

                        local transponders = require("Transponder")
                        local tablea = {}
                        local i = 1

                        for _, v in pairs(transponders) do
                            local transtag = v.transponder[1]
                            tablea[i] = v.transponder[1]
                            i = i + 1
                            transponder.setTags(tablea)
                        end
                        package.loaded['Transponder'] = nil
                    end
                end

                if pcall(require, "Transponder") and pcall(require, "Targets") and transponder then
                    unit.setTimer("loadRequired", 2)
                end
                specialRadarTargets = {}
                local amountToFilterOutAbandonedConstructs = 5 --export:
                knownContacts = {isEmpty = true}
                targetcount = 0
                function updateRadar(match)
                    if radar_size > 1 then
                        if radar_1 == radar and radar_1.getOperationalState() == -1 then radar = radar_2 end
                        if radar_2 == radar and radar_2.getOperationalState() == -1 then radar = radar_1 end
                    end
                    allies = {}
                    threats = {}
                    specialRadarTargets = {}
                    local data = radar.getWidgetData()
                    if string.len(data) < 120000 then
                        local _,_,cl = data:find('"constructsList" *: *(%b[])')
                        local constructList = cl:gmatch("%b{}") 
                        local list = {}
                        targetcount = 0
                        for str in constructList do
                            local id = tonumber(str:match('"constructId":"([%d]*)"'))
                            if not (knownContacts[id]) then
                                local tagged = not radar.hasMatchingTransponder(id)
                                if radar.hasMatchingTransponder(id) and not radar.isConstructAbandoned(id) then
                                    allies[#allies+1]=id
                                end
                                if radar.getThreatRateFrom(id) > 1 and not radar.isConstructAbandoned(id) then
                                    threats[#threats+1]=id
                                end 
                                local ident = radar.isConstructIdentified(id)
                                local randomid = getShortName(id)
                                str = string.gsub(str, 'name":"', 'name":"'..randomid..' - ')

                                if match and tagged and not
                                (radar.isConstructAbandoned(id) and #radar.getConstructIds() > amountToFilterOutAbandonedConstructs and
                                    not (radar.isConstructIdentified(id)
                                        or id == radar.getTargetId()))then
                                        targetcount = targetcount + 1
                                    list[#list+1] = str
                                elseif not match and not tagged then
                                    list[#list+1] = str
                                end
                                if targetCode == randomid then
                                    table.insert(specialRadarTargets,1,str)
                                end
                                
                                for i = 1, #requiredTargets do
                                    local requiredTarget = requiredTargets[i]

                                    if requiredTarget == randomid then
                                        table.insert(specialRadarTargets, str)
                                    end
                                end
                                
                                if not specialRadar and #specialRadarTargets > 0 then
                                    specialRadar = true
                                    specialTargetRadar()
                                end
                            end            
                        end
                        return '{"constructsList":[' .. table.concat(list, ',') .. '],' .. data:match('"elementId":".+')
                    end
                end

                radarOnlyEnemeies = true
                fm = 'Enemies'
                rf = ''
                FCS_locked = false
                local _data = updateRadar(radarOnlyEnemeies)

                local _panel = system.createWidgetPanel("RADAR")
                local _widget = system.createWidget(_panel, "value")
                radarFilter = system.createData('{"label":"Filter","' .. fm .. '' .. rf .. '","unit": ""}')
                system.addDataToWidget(radarFilter, _widget)
                local _widget = system.createWidget(_panel, "radar")
                radarData = system.createData(_data)
                system.addDataToWidget(radarData, _widget)

                specialRadar = false
                function specialTargetRadar()
                    local widgetTitel = "Targets"
                    if autoTargets then widgetTitel = widgetTitel .. " - AutoMode" end
                    specialTimer = 0
                    unit.setTimer("specialR", 0.1)
                    local data = radar.getWidgetData()
                    local _dataS = '{"constructsList":[' .. table.concat(specialRadarTargets, ',') .. '],' ..
                        data:match('"elementId":".+')
                    _panelS = system.createWidgetPanel(widgetTitel)
                    local _widgetS = system.createWidget(_panelS, "radar")
                    radarDataS = system.createData(_dataS)
                    system.addDataToWidget(radarDataS, _widgetS)
                end

                allyAmount = 0
                function getAlliedInfo()
                    local htmlAllies = ""
                    allyAmount = #allies
                    local tooMany = false
                    if allyAmount > maxAllies then tooMany = true end
                    for i = 1, #allies do
                        if i < (maxAllies + 1) then
                            local id = allies[i]
                            local allyShipInfo = "[" ..
                                radar.getConstructCoreSize(id) .. "]-" .. getShortName(id) .. "- " .. radar.getConstructName(id)
                            local owner = getFriendlyDetails(id)
                            htmlAllies = htmlAllies .. [[<tr>
                                                <td>]] .. allyShipInfo .. [[</td>
                                                <td>]] .. owner .. [[</td>
                                                </tr>]]
                        end
                    end
                    if tooMany then
                        htmlAllies = htmlAllies .. [[<tr>
                                                <td colspan="2">Plus ]] .. (allyAmount - maxAllies) .. [[ more allies</td>
                                                </tr>]]
                    end
                    return htmlAllies
                end

                function alliesHead()
                    if allyAmount == 0 then
                        return ""
                    else
                        local alliesHead = [[<tr>
                                    <th style="width:max-content;max-width:80%">ShipInfo</th>
                                    <th style="width:max-content;max-width:30%">Owner</th>
                                    </tr>]]
                        return alliesHead
                    end
                end

                function drawAlliesHtml()
                    alliesHtml = [[
                                    <html>
                                        <div class="allies">
                                        <table class="customTable">
                                            <thead>
                                                <h2>Targets: ]] .. targetcount .. [[</h2><br>
                                                <h2>Allies: ]] .. allyAmount .. [[</h2><br>]] .. alliesHead() .. [[</thead>
                                            <tbody>]] .. getAlliedInfo() .. [[</tbody>
                                        </table></div>
                                    </html>]]
                end

                function drawThreatsHtml()
                    threatsAmount = #threats
                    function threatsHead()
                        if threatsAmount == 0 then
                            return ""
                        else
                            local threatsHead = [[
                                            <tr>
                                                <th style="width:max-content;max-width:80%">ShipInfo</th>
                                                <th style="width:max-content;max-width:50%">Threat Lvl</th>
                                            </tr>]]
                            return threatsHead
                        end
                    end

                    function getThreatsInfo()
                        local threatInfo = ""
                        for i = 1, threatsAmount do
                            local id = threats[i]
                            local threatDist = radar.getConstructDistance(id)

                            if threatDist < 1000 then
                                threatDist = string.format('%0.2f', threatDist) .. "m"
                            elseif threatDist < 100000 then
                                threatDist = string.format('%0.2f', threatDist / 1000) .. "km"
                            else
                                threatDist = string.format('%0.2f', threatDist / 200000) .. "su"
                            end
                            local threatShipInfo = "[" ..
                                radar.getConstructCoreSize(id) ..
                                "]-" .. getShortName(id) .. "- " .. radar.getConstructName(id) .. " - " .. threatDist
                            local threat = radar.getThreatRateFrom(id)
                            local threatRateString = { "None", "Identified", "Stopped shooting", "Threatened", "Attacked" }
                            local color = "red"
                            if threat == 1 or threat == 2 then
                                color = "orange"
                            end
                            threatInfo = threatInfo .. [[<tr style=color:]] .. color .. [[>
                                                    <td>]] .. threatShipInfo .. [[</td>
                                                    <td>]] .. threatRateString[threat] .. [[</td>
                                                    </tr>]]
                        end
                        return threatInfo
                    end

                    threatsHtml = [[
                                    <div class="locked">
                                        <table class="customTable">
                                            <thead>
                                                <h2 style="color:red;text-align:right">Threats: ]] ..
                        threatsAmount .. [[</h2><br>]] .. threatsHead() .. [[
                                                <tbody>]] .. getThreatsInfo() .. [[</tbody>
                                        </table>
                                    </div>]]
                end

                cssAllyLocked = [[<style>
                                    .allies {
                                        position: fixed;
                                        top: 25px;
                                        width: 15%;
                                        color: white;
                                    }
                                    .locked {
                                        position: fixed;
                                        top: 14%;
                                        right: 20px;
                                        width: 15%;
                                        color: red;
                                    }
                                    table.customTable {
                                        border-collapse: collapse;
                                        border-width: 2px;
                                        background: #142027;
                                        opacity: 0.8;
                                        font-family: "Lucida" Grande, sans-serif;
                                        font-size: 12px;
                                        border-radius: 5px;
                                        border: 0.2vh solid;
                                        border-color: #098dfe
                                    }

                                    table.customTable td, table.customTable th {
                                        border-width: 2px;
                                        border-color: #7EA8F8;
                                        border-style: solid;
                                        border-radius: 5px;
                                        padding: 5px;
                                    }
                                    .h2{
                                        font-family: "Lucida" Grande, sans-serif;
                                    }

                                    </style>]]

                ownShipId = construct.getId()
                ownShipName = construct.getName()
                own3Letter = getShortName(ownShipId)
                ownInfoHtml = [[
                                <style>
                                .ownShipInfo{
                                    font-family: "Lucida" Grande, sans-serif;
                                    position: fixed;
                                    bottom: 10px;
                                }
                                </style>
                                <div class="ownShipInfo">
                                    <h4>]] .. ownShipId .. " [" .. own3Letter .. "] " .. ownShipName .. [[<h4>
                                </div>
                                ]]

                if showAllies then
                    drawAlliesHtml()
                end
                borderWidth = 0
                borderColor = "red"
                borderActive = false
                function alarmBorder()
                    alarmStyles = [[<style>
                                .alarmBorder {
                                    width:100%;
                                    height:100%;
                                    box-shadow: 0 0 ]] .. borderWidth .. [[px 0px ]] .. borderColor .. [[ inset;
                                    }</style>
                                    <html class='alarmBorder'></html>]]
                end

                function comma_value(amount)
                    local formatted = amount
                    while true do
                        formatted, k = string.gsub(formatted, "^(-?%d+)(%d%d%d)", '%1,%2')
                        if (k == 0) then
                            break
                        end
                    end
                    return formatted
                end

                local enemyInfoDmg = "";
                dmgTable = {}
                local dmgDone = 0;
                local dmgDoneFormatted = "0";
                local dmgPercent = 0;

                function addDmgToTable(id, dmg, weapon)
                    local ammoId = weapon.getAmmo()
                    local ammoType = system.getItem(ammoId).displayName
                    local displayType = ""
                    if string.find(ammoType, "Kinetic") then
                        displayType = "Kinetic"
                    elseif string.find(ammoType, "Thermic") then
                        displayType = "Thermic"
                    elseif string.find(ammoType, "Antimatter") then
                        displayType = "Antimatter"
                    elseif string.find(ammoType, "Electromagnetic") then
                        displayType = "Electromagnetic"
                    end
                    local damage = string.format('%0.2f', (dmg / 1000)) .. "k"
                    if printHitAndMiss then
                        system.print(radar.getConstructName(id) .. " hit for " .. string.format('%0.2f', (dmg / 1000)) .. "k damage (" .. displayType .. ")")
                    end
                    if showFloatyText then
                        table.insert(floatyText, { timer = 0, text = damage, hit = true })
                    end
                    if not calculating then
                        calculating = true
                        unit.setTimer("DPS",1)
                    end
                    local prevDmg = dmgTable[id]
                    if prevDmg == nil then
                        dmgTable[id] = dmg
                    else
                        dmgTable[id] = prevDmg + dmg
                    end
                end
                function printMiss(id)
                    if printHitAndMiss then
                        system.print("Missed " .. radar.getConstructName(id))
                    end
                    if showFloatyText then
                        table.insert(floatyText, {timer=0,text="Miss",hit=false})
                    end
                end
                
                endfloatyText = {}
                floatyHtml = ""
                showFloatyText = true
                function floatyTextF()
                    floatyHtml = ""
                    if showFloatyText then
                        for k, v in pairs(floatyText) do
                            local color = "#80ffff"
                            local factor = 1
                            v.timer = v.timer + 0.02
                            if (v.timer >= 2) then table.remove(floatyText, k) end
                            if not v.hit then
                                color = "red"
                                factor = -1
                            end
                            local x = screenWidth * (0.5 - factor * 0.05) - factor * v.timer * 30
                            local y = screenHeight * 0.47 - v.timer * 30
                            floatyHtml = floatyHtml .. [[
                            <style>
                            .floatyText]] .. k .. [[{
                            position: fixed;
                            top: ]] .. y .. [[px;
                            right: ]] .. x .. [[px;
                            color: ]] .. color .. [[;
                            font-family: "Lucida" Grande, sans-serif;
                            font-size:]] .. 40 - v.timer * 10 .. [[px;
                            transform: translateX(50%);
                            
                            opacity: ]] .. 1 - v.timer / 2 .. [[

                        }
                        
                            </style>
                            
                            <div  class="floatyText]] .. k .. [[">
                            ]] .. v.text .. [[
                            </div>
                            ]]

                        end
                    end

                end
                counter = 1
                dpsTable = {}
                dps = "~"
                ttTenMil = 0
                ttTenMilString = "--:--"
                calculating = false
                lastDmgValue = 0
                function enemyDPS()
                    local incDmg = 0
                    local newDmgValue = dmgTable[radar.getTargetId()] or 0
                    local diff = newDmgValue - lastDmgValue
                    if diff < 0 then
                        unit.stopTimer("DPS")
                        dpsTable = {}
                        counter = 1
                        dps = "~"
                        ttTenMil = 0
                        ttTenMilString = "--:--"
                        calculating = false
                        lastDmgValue = 0
                    end
                    dpsTable[counter] = diff
                    counter = counter + 1
                    lastDmgValue = newDmgValue
                    local dpsTableLenght = #dpsTable
                    for i = 1, dpsTableLenght do
                        incDmg = incDmg + dpsTable[i]
                    end

                    if counter > 60 then
                        counter = 1
                    end
                    if dpsTableLenght > 10 then
                        dps = incDmg / dpsTableLenght
                        if counter % 5 == 0 then
                            ttTenMil = (10000000 - newDmgValue) / dps
                            ttTenMilString = "~" .. seconds_to_clock(ttTenMil)
                        elseif ttTenMil > 0 then
                            ttTenMil = ttTenMil - 1
                            ttTenMilString = "~" .. seconds_to_clock(ttTenMil)
                        end
                        if ttTenMil < 0 then ttTenMilString = "" end
                        dps = round(dps / 1000, 2) .. "k"
                    end
                    if incDmg < 1 and dpsTableLenght == 60 then
                        unit.stopTimer("DPS")
                        dpsTable = {}
                        counter = 1
                        dps = "~"
                        ttTenMil = 0
                        ttTenMilString = "--:--"
                        calculating = false
                        lastDmgValue = 0
                    end
                end

                function round(num, numDecimalPlaces)
                    local mult = 10 ^ (numDecimalPlaces or 0)
                    return math.floor(num * mult + 0.5) / mult
                end

                function getMaxSpeedByMass(m)
                    if m then
                    local speed = 50000/3.6-10713*(m-10000)/(853926+(m-10000))
                    speed = speed *3.6
                    if speed > 50000 then
                        speed = 50000
                    elseif speed < 20000 then
                        speed = 20000
                    end
                    return speed
                        end
                end
                local oldTargetSpeed = nil
                local speedCounter = 0
                local speedAnnounced = nil
                local speedUpOrDown = ""
                local callSpeed = true --export:
                local callSpeedChange = true --export:
                local speedChange = ""
                function drawEnemyInfoDmgBar()
                    local targetId = radar.getTargetId()
                    if targetId == 0 then
                        enemyInfoDmg = "";
                        oldTargetSpeed = nil
                        speedCounter = 0
                        speedAnnounced = nil
                        speedUpOrDown = ""
                        speedChange = ""
                        maxSpeed = 0
                        return
                    end
                    local isIdentified = radar.isConstructIdentified(targetId)


                    dmgDone = dmgTable[targetId] or 0;
                    dmgPercent = (dmgDone / 100000)
                    if dmgPercent > 100 then dmgPercent = 100 end
                    if dmgDone > 1000000 then
                        dmgDoneFormatted = string.format('%0.2f', (dmgDone / 1000000)) .. "M"
                    elseif dmgDone > 1000 then
                        dmgDoneFormatted = string.format('%0.2f', (dmgDone / 1000)) .. "k"
                    else
                        dmgDoneFormatted = ""
                    end
                    targetDistance = math.floor(radar.getConstructDistance(targetId))
                    targetName = "[" ..
                        radar.getConstructCoreSize(targetId) .. "]-" ..
                        getShortName(targetId) .. "- " .. radar.getConstructName(targetId)
                    targetSpeed = math.floor(radar.getConstructSpeed(targetId) * 3.6)
                    if targetSpeed > oldSpeed then
                        speedChangeIcon = "↑"
                    elseif targetSpeed < oldSpeed then
                        speedChangeIcon = "↓"
                    else
                        speedChangeIcon = "→"
                    end
                    if not oldTargetSpeed then oldTargetSpeed = targetSpeed end
                    if callSpeed then
                        local factor = math.floor(round(targetSpeed / 5000))
                        if not speedAnnounced then speedAnnounced = 5000 * factor end
                        if speedAnnounced ~= 5000 * factor and targetSpeed > 5000 * factor - 100 and
                            targetSpeed < 5000 * factor + 100 then
                            table.insert(Sound, "speed" .. 5000 * factor)
                            oldTargetSpeed = targetSpeed
                            speedAnnounced = 5000 * factor
                        end
                    end

                    if callSpeedChange and isIdentified then
                        local speedChangeLimit = 500
                        if targetSpeed - oldTargetSpeed > speedChangeLimit then
                            oldTargetSpeed = targetSpeed
                            speedCounter = 0
                            if speedUpOrDown ~= "up" then
                                speedUpOrDown = "up"
                                speedChange = "Increasing"
                                table.insert(Sound, "speedup")
                            end
                        elseif oldTargetSpeed - targetSpeed > speedChangeLimit then
                            oldTargetSpeed = targetSpeed
                            speedCounter = 0
                            if speedUpOrDown ~= "down" then
                                speedUpOrDown = "down"
                                speedChange = "Braking"
                                table.insert(Sound, "speeddown")
                            end
                        else
                            if speedCounter < 100 then
                                speedCounter = speedCounter + 1
                            else
                                if speedUpOrDown ~= "holding" then
                                    speedUpOrDown = "holding"
                                    speedChange = "Holding"
                                    table.insert(Sound, "speedholding")
                                end
                                speedCounter = 0
                            end
                        end
                    end

                    if targetDistance > oldTargetDistance then
                        distanceChangeIcon = "↑"
                    elseif targetDistance < oldTargetDistance then
                        distanceChangeIcon = "↓"
                    else
                        distanceChangeIcon = "→"
                    end
                    oldTargetDistance = targetDistance
                    oldSpeed = targetSpeed

                    if targetDistance < 1000 then
                        distanceUnit = "m"
                    elseif targetDistance < 100000 then
                        targetDistance = targetDistance / 1000
                        distanceUnit = "km"
                    else
                        targetDistance = targetDistance / 200000
                        distanceUnit = "su"
                    end
                    local maxSpeed = isIdentified and comma_value(math.floor(getMaxSpeedByMass(radar.getConstructMass(targetId)))) or 0
                    probil = weapon_1 and math.floor(json.decode(weapon_1.getWidgetData()).properties.hitProbability * 100) or 0
                    enemyInfoDmg = [[<style>
                    .enemyInfoCss {
                    position: fixed;
                    top: 8%;
                    left: 50%;
                    transform: translateX(-50%);
                    width: 560px;
                    color: #80ffff;
                    text-align: center;
                }

                    .enemySpeed{
                    position: fixed;
                    top: 50%;
                    left: 35%;
                }
                    .dmgDoneLabels {
                    display: grid;
                    grid-template-columns: auto auto auto;
                    font-size: 12px;
                }
                    .targetInfoLabels {
                    display: grid;
                    grid-template-columns: 25% 25% 25% 25%;
                    font-size:14px;
                }
                    </style>
                    <div class="enemySpeed">Speed: ]] .. comma_value(targetSpeed) .. [[km/h <br>]]
                        .. speedChange .. [[</div>
                    <div class="enemyInfoCss">
                    <h3 style="text-align: center;">*]] .. targetName .. [[*</h3>
                    <div>
                    <svg width="100%" height="24px" style="font-family: Calibri;fill:white;stroke:#80ffff;font-weight:bold">
                    <rect x="0" y="0" rx="10" ry="10" width="100%" height="24" style="fill:#142027;stroke:#098dfe;stroke-width:1;opacity:0.8" />

                    <rect x="0" y="1" rx="10" ry="10" width="]] ..
                        dmgPercent .. [[%" height="22" style="fill:red;stroke:black;stroke-width:0;opacity:0.5" />
                    <text x="50%" y="18"  text-anchor="middle">]] .. dmgDoneFormatted .. [[</text>
                    </svg>
                    </div>
                    <div class="dmgDoneLabels">
                    <div style="text-align: left;">0</div>
                    <div style="text-align: center;">5mil</div>
                    <div style="text-align: right;">10mil</div>
                    </div>]]
                    if isIdentified then
                        enemyInfoDmg = enemyInfoDmg ..
                            [[<h3>Hitchance</h3>
                        <div>
                        <svg width="80%" height="24px" style="font-family: Calibri;fill:white;stroke:#80ffff;font-weight:bold">
                        <rect x="0" y="0" rx="10" ry="10" width="100%" height="24"
                        style="fill:#142027;stroke:#098dfe;stroke-width:1;opacity:0.8" />

                        <rect x="0" y="1" rx="10" ry="10" width="]] .. probil .. [[%" height="22"
                        style="fill:gray;stroke:black;stroke-width:0;opacity:0.5" />
                        <text x="50%" y="18"  text-anchor="middle">]] .. probil .. [[%</text>
                        </svg>
                        </div>
                        ]]
                    end
                    enemyInfoDmg = enemyInfoDmg .. [[
                    <div class="targetInfoLabels">
                    <div>]] ..
                        distanceChangeIcon .. " " .. round(targetDistance, 2) .. distanceUnit .. [[</div>]]
                    if isIdentified then
                        enemyInfoDmg = enemyInfoDmg .. [[
                        <div>]] .. "max: " .. maxSpeed .. [[km/h</div>
                        <div>]] .. dps .. [[ dps</div>
                        <div>]] .. ttTenMilString .. [[</div>
                        <div></div>
                        <div>Current: ]].. speedChangeIcon  .. comma_value(targetSpeed) .. [[km/h</div>
                        ]]
                    end
                    enemyInfoDmg = enemyInfoDmg .. [[ </div></div>]]

                end
                screenHeight = system.getScreenHeight()
                screenWidth = system.getScreenWidth()
                function crossHair()
                    local l = targetDistance
                    if l < 100000 then l = 100000 end
                    local pcrossHair = vec3(construct.getWorldPosition()) + l * vec3(construct.getWorldForward())
                    local ocrossHair = library.getPointOnScreen({ pcrossHair['x'], pcrossHair['y'], pcrossHair['z'] })
                    local x = ocrossHair[1]
                    local y = ocrossHair[2]
                    if x > 0 and y > 0 then
                        return [[<div style="position: fixed;left: ]] ..
                            screenWidth * x ..
                            [[px;top:]] ..
                            screenHeight * y ..
                            [[px;width:15px;height:15px;"><svg viewBox="0 0 1024 1024" ><path fill="currentColor" d="M512 896a384 384 0 1 0 0-768 384 384 0 0 0 0 768zm0 64a448 448 0 1 1 0-896 448 448 0 0 1 0 896z"></path><path fill="currentColor" d="M512 96a32 32 0 0 1 32 32v192a32 32 0 0 1-64 0V128a32 32 0 0 1 32-32zm0 576a32 32 0 0 1 32 32v192a32 32 0 1 1-64 0V704a32 32 0 0 1 32-32zM96 512a32 32 0 0 1 32-32h192a32 32 0 0 1 0 64H128a32 32 0 0 1-32-32zm576 0a32 32 0 0 1 32-32h192a32 32 0 1 1 0 64H704a32 32 0 0 1-32-32z"></path></svg></div>]]
                    else
                        return ""
                    end 
                end

                alliesAR = ""
                function drawAlliesOnScreen()
                    if lshiftPressed then
                        alliesAR = [[<svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">]]
                        for _, v in ipairs(allies) do
                            local point = vec3(radar.getConstructWorldPos(v))
                            local allyPosOnScreen = library.getPointOnScreen({ point['x'], point['y'], point['z'] })
                            local x = screenWidth * allyPosOnScreen[1]
                            local y = screenHeight * allyPosOnScreen[2]
                            if x > 0 and y > 0 then
                                alliesAR = alliesAR ..
                                    [[<circle cx="]] ..
                                    x ..
                                    [[" cy="]] ..
                                    y ..
                                    [[" r="5" stroke="green" stroke-width="2" style="fill-opacity:0" /><text x="]] ..
                                    x + 10 .. [[" y="]] .. y + 10 .. [[" fill="white">]] .. getFriendlyDetails(v) .. [[</text>]]
                            end
                        end
                        alliesAR = alliesAR .. "</svg>"
                    else
                        alliesAR = ""
                    end
                end
                enemyDPSHtml = ""
                function zeroConvertToWorldCoordinates(cl)
                    local q = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
                    local cm = '::pos{' .. q .. ',' .. q .. ',' .. q .. ',' .. q .. ',' .. q .. '}'
                    local cn, co, ci, cj, ch = string.match(cl, cm)
                    if cn == '0' and co == '0' then
                        return vec3(tonumber(ci), tonumber(cj), tonumber(ch))
                    end
                    cj = math.rad(cj)
                    ci = math.rad(ci)

                    local planet = atlas[tonumber(cn)][tonumber(co)]

                    local cp = math.cos(ci)
                    local cq = vec3(cp * math.cos(cj), cp * math.sin(cj), math.sin(ci))
                    return (vec3(planet.center) + (planet.radius + ch) * cq)
                end
                hasCustomWaypoints, customWaypoints = pcall(require, "customWaypoints")
                if hasCustomWaypoints then
                    system.print("--------------")
                    system.print("Loaded ".. #customWaypoints .. " Custom Waypoints for AR:")
                    for _, v in pairs(customWaypoints) do
                        system.print(v.name)
                        v.pos = vec3(zeroConvertToWorldCoordinates(v.pos))
                        v.offset = math.random(-10, 10)
                    end
                    system.print("--------------")
                else
                    customWaypoints = {}
                end
                filteredWaypoints = customWaypoints
                customWaypointsAR = ""
                function drawCustomWaypointsOnScreen()
                    if lshiftPressed then
                        customWaypointsAR = [[<svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">]]
                        for _, v in pairs(filteredWaypoints) do
                            local point = v.pos
                            local distance = (point - vec3(construct.getWorldPosition())):len()
                            local customWaypointsPosOnScreen = library.getPointOnScreen({ point['x'], point['y'], point['z'] })
                            local x = screenWidth * customWaypointsPosOnScreen[1]
                            local y = screenHeight * customWaypointsPosOnScreen[2]
                            local color = v.color or "red"
                            local pipeDist = getPipeDistance(point)
                            local eta = getETA(distance, pipeDist, x, y)
                            if x > 0 and y > 0 then
                                customWaypointsAR = customWaypointsAR ..
                                    [[<rect x="]] ..
                                    x - 5 ..
                                    [[" y="]] ..
                                    y - 5 ..
                                    [[" rx="2" ry="2" stroke="]] ..
                                    color .. [[" width="10" height="10" stroke-width="2" style="fill-opacity:0" /><text x="]] ..
                                    x + 10 ..
                                    [[" y="]] ..
                                    y + 10 + v.offset ..
                                    [[" fill="white">]] .. v.name .. " " .. getDistanceDisplayString(distance) .. [[</text>]] .. eta
                            end
                        end
                        customWaypointsAR = customWaypointsAR .. "</svg>"
                    else
                        customWaypointsAR = ""
                    end
                end
                function getPipeDistance(worldPos)
                    local origin = vec3(construct.getWorldPosition())
                    local destination = origin + vec3(construct.getWorldVelocity())
                    local pipeDistance
                    local pipe = (destination - origin):normalize()
                    local r = (worldPos - origin):dot(pipe) / pipe:dot(pipe)
                    local L = origin + (r * pipe)
                    pipeDistance = (L - worldPos):len()
                    return pipeDistance
                end

                function getETA(distance, pipeDist, x, y)
                    if distance / 200000 > 100 and pipeDist < 600000 or pipeDist < 100000 then
                        local time = distance / vec3(construct.getWorldVelocity()):len()
                        if time < 10 * 60 * 60 then
                            return [[<text x="]] ..
                                x + 10 ..
                                [[" y="]] ..
                                y + 30 .. [[" fill="#c7dcff">ETA ]] .. seconds_to_clock(time) .. [[</text>]]
                        end
                    end
                    return ""
                end
                mouseHtml = ""
                leftAltPressed = false
                function drawMouse()
                    if leftAltPressed then
                        local x = system.getMousePosX()
                        local y = system.getMousePosY()
                        mouseHtml = [[<svg  width="100%" height="100%" style="position: absolute;left:0%;top:0%;"><circle cx=]] ..
                            x .. [[ cy=]] .. y .. [[ r=2 stroke="red" stroke-width="3" fill="red"></svg>]]
                    else
                        mouseHtml = ""
                    end
                end
                function radarRange()
                    local radarIdentificationRange = radar.getIdentifyRanges()[1]
                    if radarIdentificationRange == nil then return "" end
                    local distanceUnit
                    if radarIdentificationRange < 1000 then
                        distanceUnit = "m"
                    elseif radarIdentificationRange < 100000 then
                        radarIdentificationRange = radarIdentificationRange / 1000
                        distanceUnit = "km"
                    else
                        radarIdentificationRange = radarIdentificationRange / 200000
                        distanceUnit = "su"
                    end
                    return [[<style> .radarInfo{
                        position: fixed;
                        top: 10px;
                        right: 10px;
                    }</style><div class="radarInfo">Radar-Range: ]] .. round(radarIdentificationRange, 2) .. distanceUnit .. [[</div>]]

                end
                targetVektorPointInfront = 10 --export:
                targetVektorFromTarget = {} 
                TargetVektorInfo = {}
                function calculateVektor()
                    local l = #targetVektorFromTarget
                    local P = targetVektorFromTarget[l - 1]
                    local Q = targetVektorFromTarget[l]
                    local abstand = P:dist(Q)
                    --system.print(abstand)
                    local meter = 200000 * targetVektorPointInfront
                    local lambda = meter / abstand
                    local richtungsVerktor = Q - P
                    local R = P + lambda * richtungsVerktor
                    TargetVektorInfo.currentPoint = R
                    TargetVektorInfo.vector = richtungsVerktor:normalize()
                    --new
                    -- v = s / t in m/s
                    TargetVektorInfo.currentEstimatePosition = Q
                    TargetVektorInfo.startPos = Q
                    TargetVektorInfo.estimateSpeed = abstand / (TargetVektorInfo.secondTime - TargetVektorInfo.firstTime)
                    TargetVektorInfo.displaySpeed = comma_value(math.floor(TargetVektorInfo.estimateSpeed * 3.6))
                    TargetVektorInfo.displayName = targetName or "Target"
                    setCalculatedWaypoint(R)
                    TargetVektorInfo.isTracking = true
                end
                function calculateAcceleration()
                    local P = targetVektorFromTarget[1]
                    local Q = targetVektorFromTarget[2]
                    local R = targetVektorFromTarget[3]
                    local deltaT1 = TargetVektorInfo.thirdTime - TargetVektorInfo.firstTime
                    local deltaT2 = TargetVektorInfo.thirdTime - TargetVektorInfo.secondTime
                    local speed1 = P:dist(Q) / (TargetVektorInfo.secondTime - TargetVektorInfo.firstTime)
                    local speed2 = Q:dist(R) / (TargetVektorInfo.thirdTime - TargetVektorInfo.secondTime)
                    local acceleration = -(speed2 - speed1) / (deltaT2 - deltaT1)
                    TargetVektorInfo.displayAcceleration = string.format("%.2f G's", acceleration/9.81)
                    system.print("Estimated Acceleration: "..TargetVektorInfo.displayAcceleration)
                    -- check if the target is moving in a straight line
                    local angle = math.deg((Q - P):angle_between(R - Q))
                    system.print(string.format("Angle difference of 2 Vectors %.2f°", angle))
                end
                function exportTargetVector()
                    local p = TargetVektorInfo.startPos
                    local v = TargetVektorInfo.vector
                    local exportString = string.format(
                        "estimateSpeed = %f,timestamp = %f,startpos = { %f , %f , %f },vector = { %f , %f , %f },",
                        TargetVektorInfo.estimateSpeed, TargetVektorInfo.secondTime, p.x, p.y, p.z, v.x, v.y, v.z)
                    system.print(exportString)
                end

                function importTargetVector()
                    local hasTargetVector, TargetVector = pcall(require, "targetVectorExport")
                    if not hasTargetVector then return end
                    TargetVektorInfo.estimateSpeed = TargetVector.estimateSpeed
                    TargetVektorInfo.displaySpeed = comma_value(math.floor(TargetVektorInfo.estimateSpeed * 3.6))
                    TargetVektorInfo.secondTime = TargetVector.timestamp
                    TargetVektorInfo.startPos = vec3(TargetVector.startpos)
                    TargetVektorInfo.vector = vec3(TargetVector.vector)
                    TargetVektorInfo.displayName = "Target"
                    TargetVektorInfo.isTracking = true
                    TargetVektorInfo.manualSpeed = nil
                    TargetVektorInfo.currentPoint = TargetVektorInfo.startPos
                end
              
                function drawEstimatePos()
                    if not (TargetVektorInfo.isTracking) then
                        estiamtedPos = ""
                        return
                    end
                    local newTime                            = system.getUtcTime()
                    local speed                              = TargetVektorInfo.manualSpeed or TargetVektorInfo.estimateSpeed
                    local distTraveled                       = speed * (newTime - TargetVektorInfo.secondTime)
                    TargetVektorInfo.currentEstimatePosition = TargetVektorInfo.startPos +
                        distTraveled * TargetVektorInfo.vector
                    local point = vec3(TargetVektorInfo.currentEstimatePosition)
                    local estimatePosDraw = library.getPointOnScreen({ point['x'], point['y'], point['z'] })
                    local distance = (point - vec3(construct.getWorldPosition())):len()
                    local x = screenWidth * estimatePosDraw[1]
                    local y = screenHeight * estimatePosDraw[2]
                    if x > 0 and y > 0 then
                        local centerX = screenWidth / 2
                        local centerY = screenHeight / 2
                        local distanceFromCenter = math.sqrt((x - centerX) ^ 2 + (y - centerY) ^ 2)
                        local opacity = distanceFromCenter /
                            (screenWidth / 2) 
                        opacity = math.max(1 - math.min(opacity * 2, 1), 0.5) 

                        estiamtedPos = [[<div style="position: fixed;left: ]] ..
                            x ..
                            [[px;top:]] ..
                            y ..
                            [[px;opacity: ]] ..
                            opacity ..
                            [[;"><svg fill="gold" height="20px" width="20px" version="1.1" id="Capa_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
                    viewBox="0 0 384.772 384.772" xml:space="preserve">
                    <path d="M248.706,101.626c16.157-20.383,27.593-46.638,31.85-71.926c0.91-5.408-1.365-10.859-5.85-14.016
                        c-4.486-3.156-10.384-3.46-15.168-0.777c-0.242,0.136-24.576,13.57-56.434,13.57c-21.202,0-40.67-6.049-57.86-17.979
                        C134.921,3.336,126.693,0,119.348,0c-7.008,0-13.219,3.169-17.041,8.695c-2.786,4.028-4.199,9.11-4.199,15.105
                        c0,19.444,14.778,48.827,27.433,68.08c2.548,3.876,5.347,7.888,8.353,11.858c-39.632,38.957-81.508,101.904-81.508,157.351
                        c0,87.943,62.682,123.684,140,123.684c77.318,0,140-35.74,140-123.684C332.386,204.628,288.964,140.392,248.706,101.626z
                        M230.779,282.948c-6.581,6.251-15.387,10.417-26.217,12.432v20.075c0,6.892-5.587,12.479-12.479,12.479
                        s-12.478-5.587-12.478-12.479v-19.41c-15.81-2.142-27.643-8.99-35.16-20.397c-2.302-3.491-2.701-7.904-1.063-11.751
                        c1.638-3.849,5.093-6.621,9.204-7.384l9.42-1.749c4.819-0.896,9.719,1.116,12.52,5.141c3.543,5.093,9.539,7.674,17.819,7.674
                        c12.755,0,12.755-5.071,12.755-6.737c0-2.416-0.906-4.175-2.853-5.531c-1.988-1.387-5.61-2.62-10.764-3.668
                        c-20.721-4.223-34.068-9.704-39.682-16.294c-5.694-6.684-8.463-14.155-8.463-22.841c0-9.434,3.114-17.924,9.258-25.236
                        c5.945-7.08,15.035-11.674,27.009-13.679v-14.367c0-6.892,5.586-12.479,12.478-12.479s12.479,5.587,12.479,12.479v14.633
                        c10.719,2.047,19.085,6.378,25.44,13.176c2.931,3.135,4.045,7.556,2.951,11.703c-1.094,4.15-4.244,7.447-8.338,8.728l-6.464,2.023
                        c-4.688,1.468-9.802,0.046-13.063-3.63c-3.251-3.666-8.077-5.524-14.343-5.524c-5.046,0-11.063,1.201-11.063,6.926
                        c0,1.62,0.621,3.081,1.796,4.227c1.23,1.201,4.817,2.474,10.665,3.778c13.494,2.952,23.359,5.645,29.265,7.995
                        c5.984,2.387,11.028,6.474,14.993,12.152c3.968,5.669,5.983,12.468,5.983,20.197C242.386,266.434,238.481,275.632,230.779,282.948z
                        M183.689,110c-2.628,0-10.756-3.764-22.7-18.01c-9.527-11.362-18.932-26.329-25.802-41.063c-3.368-7.223-5.472-13.002-6.754-17.406
                        c0.186,0.126,0.373,0.256,0.564,0.389c22.053,15.304,46.986,23.063,74.106,23.063c16.069,0,30.572-2.771,42.183-6.091
                        C232.265,84.407,206.971,110,183.689,110z"/></svg>]]
                        if opacity > 0.5 then
                            estiamtedPos = estiamtedPos ..
                                TargetVektorInfo.displayName ..
                                [[<div style="margin-left: 25px">]] .. getDistanceDisplayString(distance) ..
                                "<br>Speed: " .. TargetVektorInfo.displaySpeed .. "km/h</div>"
                        else
                            estiamtedPos = estiamtedPos .. getDistanceDisplayString(distance)
                        end
                        estiamtedPos = estiamtedPos .. [[</div>]]
                    else
                        estiamtedPos = ""
                    end
                end
                function moveTargetVectorPoint(amount)
                    if not (TargetVektorInfo.currentPoint and TargetVektorInfo.vector) then return end
                   
                    local newPoint = TargetVektorInfo.currentPoint +  200000*amount * TargetVektorInfo.vector
                    setCalculatedWaypoint(newPoint)
                    TargetVektorInfo.currentPoint = newPoint
                end
                function getPointFromTarget()
                    local targetId = radar.getTargetId()
                    if targetId == 0 then
                        system.print("No target")
                        return
                    end
                    local l = radar.getConstructDistance(targetId)
                    local targetPos = vec3(system.getCameraWorldPos()) + l * vec3(system.getCameraWorldForward())
                    addPoint(targetPos)
                end
                function addPoint(point)
                    table.insert(targetVektorFromTarget, point)
                    if (#targetVektorFromTarget == 2) then
                        system.print("Target Vektor Point 2 added")
                        TargetVektorInfo.secondTime = system.getUtcTime()
                        calculateVektor()
                    elseif (#targetVektorFromTarget == 3) then
                        system.print("Target Vektor Point 3 added")
                        TargetVektorInfo.thirdTime = system.getUtcTime()
                        calculateAcceleration()
                        calculateVektor()
                        targetVektorFromTarget = {}
                    else
                        TargetVektorInfo.firstTime = system.getUtcTime()
                        system.print("Target Vektor Point 1 added")
                    end
                end
                function setCalculatedWaypoint(waypoint)
                    system.setWaypoint("::pos{0,0," .. waypoint.x .. "," .. waypoint.y .. "," .. waypoint.z .. "}")
                end

                function drawHud()
                    drawFuelInfo()
                    brakeHud()
                    speedInfo()
                    drawPipeInfo()
                    drawMouse()
                    if shield then
                        drawEnemyDPS()
                        drawShield()
                    end
                    html = alarmStyles ..
                        cssAllyLocked ..
                        healthHtml .. alliesHtml .. customWaypointsAR .. threatsHtml .. ownInfoHtml .. enemyInfoDmg .. crossHair() ..
                        alliesAR ..
                        alienAR .. planetAR .. fuelHtml .. brakeHtml .. speedHtml .. pipeInfoHtml .. ShieldDisplay.HTML .. mouseHtml..radarRange()..floatyHtml..estiamtedPos
                    system.setScreen(html)
                end

                if switch_1 ~= nil then switch_1.activate() end
                getMaxCorestress()
                system.setScreen(html)
                system.showScreen(1)
                unit.setTimer("hud", 0.1)
                unit.setTimer("radar", 0.4)
                unit.setTimer("clean", 30)
    
        onStop:
            lua: |
                if switch_1 ~= nil then switch_1.deactivate() end
        onTimer:
            args: ["specialR"]
            lua: |
                if specialTimer > tempRadarTime and not autoTargets then
                    system.destroyWidgetPanel(_panelS)
                    specialRadarTargets={}
                    specialRadar = false
                    targetCode = nil
                    unit.stopTimer("specialR")
                else
                    specialTimer = specialTimer +1
                    local data = radar.getWidgetData()
                    local _dataS = '{"constructsList":['..table.concat(specialRadarTargets,',')..'],'..data:match('"elementId":".+')
                    system.updateData(radarDataS, _dataS) 
                end
        onTimer:
            args: ["loadRequired"]
            lua: readRequiredValues()
        onTimer:
            args: ["radar"]
            lua: |
                local _data = updateRadar(radarOnlyEnemeies)
                system.updateData(radarFilter, '{"label":"Filter","value":"'..fm..''..rf..'", "unit": ""}')
                system.updateData(radarData, _data)
                zone = construct.isInPvPZone()
                printNewRadarContacts()

        onTimer:
            args: ["DPS"]
            lua: |
                enemyDPS()
        onTimer:
            args: ["clean"]
            lua: |
                collectgarbage("collect")
        onTimer:
            args: ["cleanBorder"]
            lua: |
                unit.stopTimer("cleanBorder")
                borderActive = false
                borderWidth = 0
        onTimer:
            args: ["hud"]
            lua: |
                if showAllies then
                    drawAlliesHtml()
                end
                if showThreats then
                    drawThreatsHtml()
                end
                alarmBorder()
                drawEnemyInfoDmgBar()
                drawHud()
                hideWarpDrive()
    radar_1:
        onEnter(id):
            lua: |
                newRadarContacts[#newRadarContacts+1] = id
        onLeave(id):
            lua: |
                if zone == 1 or printSZContacts then
                    local leaveTargetName = "["..radar_1.getConstructCoreSize(id).."]-"..getShortName(id).."- "..radar_1.getConstructName(id)
                    if showTime then
                        leaveTargetName = leaveTargetName..' - Time: '..seconds_to_clock(system.getArkTime())
                    end
                    if vec3(construct.getWorldVelocity()):len() < 8400 then
                        system.print("Target left: "..leaveTargetName)
                        system.playSound("targetleft.mp3")
                    end
                    
                end
    radar_2:
        onEnter(id):
            lua: |
                newRadarContacts[#newRadarContacts+1] = id
        onLeave(id):
            lua: |
                if zone == 1 or printSZContacts then
                    local leaveTargetName = "["..radar_2.getConstructCoreSize(id).."]-"..getShortName(id).."- "..radar_2.getConstructName(id)
                    if showTime then
                        leaveTargetName = leaveTargetName..' - Time: '..seconds_to_clock(system.getArkTime())
                    end
                    if vec3(construct.getWorldVelocity()):len() < 8400 then
                        system.print("Target left: "..leaveTargetName)
                        system.playSound("targetleft.mp3")
                    end
                end
    weapon_1:
        onHit(targetId,damage):
            lua: |
                addDmgToTable(targetId,damage,weapon_1)
        onMissed(targetId):
            lua: printMiss(targetId)
    weapon_2:
        onHit(targetId,damage):
            lua: |
                addDmgToTable(targetId,damage,weapon_2)
        onMissed(targetId):
            lua: printMiss(targetId)
    weapon_3:
        onHit(targetId,damage):
            lua: |
                addDmgToTable(targetId,damage,weapon_3)
        onMissed(targetId):
            lua: printMiss(targetId)
    weapon_4:
        onHit(targetId,damage):
            lua: |
                addDmgToTable(targetId,damage,weapon_4)
        onMissed(targetId):
            lua: printMiss(targetId)
    weapon_5:
        onHit(targetId,damage):
            lua: |
                addDmgToTable(targetId,damage,weapon_5)
        onMissed(targetId):
            lua: printMiss(targetId)
    weapon_6:
        onHit(targetId,damage):
            lua: |
                addDmgToTable(targetId,damage,weapon_6)
        onMissed(targetId):
            lua: printMiss(targetId)

    shield:
        onAbsorbed(hitpoints,rawHitpoints):
            lua: |
                if not calculating then
                    calculating = true
                    unit.setTimer("dps",1)
                end
        onVenting(active,restoredHitpoints):
            lua: |
                lastShield = shield.getShieldHitpoints()             
        
    system:
        onFlush:
            lua: |
                -- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu

                local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
                local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
                local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01

                local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
                local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01

                -- validate params
                pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
                yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
                rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
                torqueFactor = math.max(torqueFactor, 0.01)
                brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
                brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
                autoRollFactor = math.max(autoRollFactor, 0.01)
                turnAssistFactor = math.max(turnAssistFactor, 0.01)

                -- final inputs
                local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
                local finalRollInput = rollInput + system.getControlDeviceYawInput()
                local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
                local finalBrakeInput = brakeInput

                -- Axis
                local worldVertical = vec3(core.getWorldVertical()) -- along gravity
                local constructUp = vec3(construct.getWorldOrientationUp())
                local constructForward = vec3(construct.getWorldOrientationForward())
                local constructRight = vec3(construct.getWorldOrientationRight())
                local constructVelocity = vec3(construct.getWorldVelocity())
                local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
                local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
                local currentRollDegAbs = math.abs(currentRollDeg)
                local currentRollDegSign = utils.sign(currentRollDeg)

                -- Rotation
                local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
                local targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                                                + finalRollInput * rollSpeedFactor * constructForward
                                                + finalYawInput * yawSpeedFactor * constructUp

                -- In atmosphere?
                if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
                    local autoRollRollThreshold = 1.0
                    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
                    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                        if (rollPID == nil) then
                            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                        end
                        rollPID:inject(targetRollDeg - currentRollDeg)
                        local autoRollInput = rollPID:get()

                        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
                    end
                    local turnAssistRollThreshold = 20.0
                    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
                    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range

                        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                        local rollVerticalRatio = 0
                        if rescaleRollDegAbs < 90 then
                            rollVerticalRatio = rescaleRollDegAbs / 90
                        elseif rescaleRollDegAbs < 180 then
                            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                        end

                        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio

                        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio

                        targetAngularVelocity = targetAngularVelocity
                                            + turnAssistPitchInput * constructRight
                                            + turnAssistYawInput * constructUp
                    end
                end

                -- Engine commands
                local keepCollinearity = 1 -- for easier reading
                local dontKeepCollinearity = 0 -- for easier reading
                local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we dont go to the next priorities

                -- Rotation
                local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
                local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
                angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
                Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)

                -- Brakes
                local brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
                Nav:setEngineForceCommand('brake', brakeAcceleration)

                -- AutoNavigation regroups all the axis command by 'TargetSpeed'
                local autoNavigationEngineTags = ''
                local autoNavigationAcceleration = vec3()
                local autoNavigationUseBrake = false

                -- Longitudinal Translation
                local longitudinalEngineTags = 'thrust analog longitudinal'
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byThrottle) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
                elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                    then
                        autoNavigationUseBrake = true
                    end

                end

                -- Lateral Translation
                local lateralStrafeEngineTags = 'thrust analog lateral'
                local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
                if (lateralCommandType == axisCommandType.byThrottle) then
                    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
                    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
                elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
                    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
                end

                -- Vertical Translation
                local verticalStrafeEngineTags = 'thrust analog vertical'
                local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
                if (verticalCommandType == axisCommandType.byThrottle) then
                    local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
                    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
                elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
                    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
                    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
                    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
                end

                -- Auto Navigation (Cruise Control)
                if (autoNavigationAcceleration:len() > constants.epsilon) then
                    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
                    then
                        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
                    end
                    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
                end

                -- Rockets
                Nav:setBoosterCommand('rocket_engine')      
        
        onUpdate:
            lua: |
                Nav:update()
                drawPlanetsOnScreen()
                drawAlienCores()
                drawAlliesOnScreen()
                drawCustomWaypointsOnScreen()
                drawEstimatePos()

        onActionStart:
            args: [groundaltitudedown]
            lua: |
                radarOnlyEnemeies = not radarOnlyEnemeies
                if radarOnlyEnemeies then
                    fm = 'Enemies'
                else
                    fm = 'Friends'
                end
        onInputText(text):
            lua: |
                local function isFilterCommand(inputString)
                    return inputString:match("^/filter") ~= nil
                end

                local function parseFilterString(filterString)
                    local distance, area, rarity
                    local distance_match = filterString:match("-d (%d+)")
                    if distance_match then distance = tonumber(distance_match) end
                    local area_match = filterString:match("-a ([%w, ]+)")
                    if area_match then area = area_match end
                    local rarity_match = filterString:match("-r ([%w, ]+)")
                    if rarity_match then rarity = rarity_match end
                    return { distance = tonumber(distance) or nil, area = area or nil, rarity = rarity or nil }
                end

                local function filterWaypoints(waypoints, filter)
                    local filteredWaypoints = {}
                    for _, waypoint in pairs(waypoints) do
                        local waypointCoordinates = waypoint.pos
                        local distance = (waypointCoordinates - vec3(construct.getWorldPosition())):len()
                        if (not filter.area or (waypoint.area and string.find(filter.area, waypoint.area))) and
                            (not filter.rarity or (waypoint.rarity and string.find(filter.rarity, waypoint.rarity))) and
                            (not filter.distance or distance < filter.distance * 200000) then
                            table.insert(filteredWaypoints, waypoint)
                        end
                    end
                    return filteredWaypoints
                end

                local beginning = text:sub(1, 5)
                if beginning == "::pos" then
                    addPoint(zeroConvertToWorldCoordinates(text))
                elseif text == "clear" then
                    system.print("Vektor points cleared")
                    targetVektorPoints = {}
                    TargetVektorInfo = {}
                elseif beginning == "/add " then
                    local words = {}
                    local name = ""
                    for word in text:gmatch("%S+") do
                        table.insert(words, word)
                        if #words > 2 then
                            name = name .. word
                        end
                    end
                    if string.find(words[2], "::pos") then
                        table.insert(customWaypoints, { name = name, pos = vec3(zeroConvertToWorldCoordinates(words[2])), color = "yellow", offset = math.random( -10, 10)})
                    end
                elseif isFilterCommand(text) then
                    local filter = parseFilterString(text)
                    system.print("Custom waypoints filtered!")
                    if filter.area then activeFilter = system.print("Area: " .. filter.area) end
                    if filter.rarity then activeFilter = system.print("Rarity: " .. filter.rarity) end
                    if filter.distance then activeFilter = system.print("Distance: " .. filter.distance .. "su") end
                    filteredWaypoints = filterWaypoints(customWaypoints, filter)
                elseif beginning == "/spee" then
                    local speed = text:match("%d+")
                    if TargetVektorInfo.isTracking and speed then
                        TargetVektorInfo.manualSpeed = speed / 3.6
                        TargetVektorInfo.displaySpeed = comma_value(math.floor(speed))
                    end
                elseif text == "/import" then
                    importTargetVector()
                elseif text == "/export" then
                    exportTargetVector()
                else
                    system.print("Searching for: " .. string.upper(text))
                    targetCode = string.upper(text)
                end
        onActionStart:
            args: [option5]
            lua: |
                autoTargets = not autoTargets
                if not autoTargets then
                    unit.stopTimer("specialR")
                    requiredTargets = {}
                    system.destroyWidgetPanel(_panelS)
                    specialRadarTargets={}
                    specialRadar = false
                    targetCode = nil
                end
        onActionStart:
            args: [option6]
            lua: |
                local list = radar.getConstructIds()
                if knownContacts.isEmpty then 
                    knownContacts.isEmpty = false
                    for _,v in pairs(list) do
                        knownContacts[v] = true
                    end
                    else 
                    knownContacts = {isEmpty = true}
                end
        onActionStart:
            args: [lshift]
            lua: |
                lshiftPressed = not lshiftPressed
        onActionStart:
            args: [option1]
            lua: |
                if shield then shield.toggle() end
        onActionStart:
            args: [option2]
            lua: |
                if shield and not shield.isVenting() and shield.getShieldHitpoints() < shield.getMaxShieldHitpoints() then
                    local started = shield.startVenting()
                    if started then
                        unit.stopTimer("dps")
                        dpmTable = {}
                        counter = 1
                        dps = "Calculating"
                        ttZ = 0
                        ttZString = "Calculating"
                        calculating = false
                    end
                elseif shield then
                    shield.stopVenting()
                end

        onActionStart:
            args: [gear]
            lua: getPointFromTarget()

        onActionStart:
            args: [light]
            lua: |
                if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
                    Nav.control.switchOffHeadlights()
                else
                    Nav.control.switchOnHeadlights()
                end

        onActionStart:
            args: [forward]
            lua: |
                pitchInput = pitchInput - 1
        onActionStop:
            args: [forward]
            lua: if not drift then pitchInput = 0 end
        onActionStart:
            args: [backward]
            lua: pitchInput = pitchInput + 1
        onActionStop:
            args: [backward]
            lua: if not drift then pitchInput = 0 end
        onActionStart:
            args: [left]
            lua: rollInput = rollInput - 1
        onActionStop:
            args: [left]
            lua: if not drift then rollInput = rollInput + 1 end
        onActionStart:
            args: [right]
            lua: |
                rollInput = rollInput + 1
        onActionStop:
            args: [right]
            lua: if not drift then rollInput = 0 end

        onActionStart:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
        onActionStop:
            args: [straferight]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)

        onActionStart:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
        onActionStop:
            args: [strafeleft]
            lua: Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)

        onActionStart:
            args: [up]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
        onActionStop:
            args: [up]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
        onActionStart:
            args: [down]
            lua: |
                Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
                Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
        onActionStop:
            args: [down]
            lua: |
                Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
                Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)

        onActionStart:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)

        onActionLoop:
            args: [groundaltitudeup]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)


        onActionStart:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)

        onActionLoop:
            args: [groundaltitudedown]
            lua: Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)

        onActionStart:
            args: [yawright]
            lua: yawInput = yawInput - 1
        onActionStop:
            args: [yawright]
            lua: if not drift then yawInput = 0 end
                
        onActionStart:
            args: [yawleft]
            lua: yawInput = yawInput + 1
        onActionStop:
            args: [yawleft]
            lua: if not drift then yawInput = 0 end
        onActionStart:
            args: [brake]
            lua: |
                if brakeToggle then brakeTroogle() else 
                    brakeInput = 1 
                    isBraking = true
                end
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStop:
            args: [brake]
            lua: |
                if not brakeToggle then
                    brakeInput = 0 
                    isBraking = false
                end

        onActionLoop:
            args: [brake]
            lua: |
                local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
                if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
                    if (math.abs(targetSpeed) > constants.epsilon) then
                        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))
                    end
                end
        onActionStart:
            args: [booster]
            lua: Nav:toggleBoosters()
        onActionStart:
            args: [stopengines]
            lua: |
                if unit.getThrottle() > 0 then
                    Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                else
                    Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal, 100)
                end
        onActionStart:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
        onActionLoop:
            args: [speedup]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
        onActionStart:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
        onActionLoop:
            args: [speeddown]
            lua: Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
        onActionStart:
            args: [up]
            lua: moveTargetVectorPoint(10)
        onActionStart:
            args: [down]
            lua: moveTargetVectorPoint(-10)
        onActionStart:
            args: [straferight]
            lua: moveTargetVectorPoint(1)
        onActionStart:
            args: [strafeleft]
            lua: moveTargetVectorPoint(-1)
        onActionStart:
            args: [antigravity]
            lua: |
                drift = not drift
                local driftFactor = 0.02 --export:
                if drift then
                    yawSpeedFactor = driftFactor
                    pitchSpeedFactor = driftFactor
                    rollSpeedFactor = driftFactor
                else
                    pitchInput = 0
                    rollInput = 0
                    yawInput = 0
                    yawSpeedFactor = 0.8
                    pitchSpeedFactor = 1
                    rollSpeedFactor = 1.5
                end
        onActionStart:
            args: [option3]
            lua: |
                brakeToggle = not brakeToggle
        onActionStart:
            args: [option4]
            lua: |
                autoAdjustShield = not autoAdjustShield
        onActionStart:
            args: [lalt]
            lua: |
                leftAltPressed = true
                system.lockView(true)
        onActionStop:
            args: [lalt]
            lua: |
                leftAltPressed = false
                system.lockView(false)
        onActionStart:
            args: [leftmouse]
            lua: |
                local x = system.getMousePosX()
                local y = system.getMousePosY()
                if shield and x > ShieldDisplay.startX and x < ShieldDisplay.startX + ShieldDisplay.totalWidth and leftAltPressed then
                    local xClicked = round((x - ShieldDisplay.startX - 30) / (ShieldDisplay.resBarWidth) * ShieldRes.maxPool, 2)
                    if xClicked < 0 then xClicked = 0 end

                    -- AM bar
                    if y > ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin and
                        y < ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin + 10 then

                        local remaining = ShieldRes.maxPool - (ShieldRes[2][1] + ShieldRes[3][1] + ShieldRes[4][1])
                        if xClicked <= remaining then
                            ShieldRes[1][1] = xClicked
                        else
                            ShieldRes[1][1] = remaining
                        end

                    end

                    -- EM bar
                    if y > ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 2 and
                        y < ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 2 + 10 then

                        local remaining = ShieldRes.maxPool - (ShieldRes[1][1] + ShieldRes[3][1] + ShieldRes[4][1])
                        if xClicked <= remaining then
                            ShieldRes[2][1] = xClicked
                        else
                            ShieldRes[2][1] = remaining
                        end
                    end

                    -- KI bar
                    if y > ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 3 and
                        y < ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 3 + 10 then
                        local remaining = ShieldRes.maxPool - (ShieldRes[1][1] + ShieldRes[2][1] + ShieldRes[4][1])
                        if xClicked <= remaining then
                            ShieldRes[3][1] = xClicked
                        else
                            ShieldRes[3][1] = remaining
                        end
                    end

                    -- TH bar
                    if y > ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 4 and
                        y < ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 4 + 10 then
                        local remaining = ShieldRes.maxPool - (ShieldRes[1][1] + ShieldRes[2][1] + ShieldRes[3][1])
                        if xClicked <= remaining then
                            ShieldRes[4][1] = xClicked
                        else
                            ShieldRes[4][1] = remaining
                        end
                    end

                    -- buttons
                    if y > ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 5 and
                        y < ShieldDisplay.startY + ShieldDisplay.barStart + ShieldDisplay.barMargin * 5 + 40 then

                        -- Set Button
                        if x > ShieldDisplay.startX + 30 * ShieldDisplay.resFactorX and
                            x < ShieldDisplay.startX + 30 * ShieldDisplay.resFactorX + 50 * ShieldDisplay.resFactorX then
                            local currentRes = shield.getResistances()
                            if not
                                (
                                currentRes[1] == ShieldRes[1][1] and currentRes[2] == ShieldRes[2][1] and
                                    currentRes[3] == ShieldRes[3][1] and
                                    currentRes[4] == ShieldRes[4][1]) then
                                local setWorked = shield.setResistances(ShieldRes[1][1], ShieldRes[2][1], ShieldRes[3][1],
                                    ShieldRes[4][1])
                                if setWorked == 0 then system.print("Failed to set Resistances") end
                            end
                        end

                        -- Reset
                        if x > ShieldDisplay.startX + 90 * ShieldDisplay.resFactorX and
                            x < ShieldDisplay.startX + 90 * ShieldDisplay.resFactorX + 50 * ShieldDisplay.resFactorX then
                            for i = 1, 4, 1 do
                                ShieldRes[i][1] = 0
                            end
                        end
                        -- autoadjust
                        if x > ShieldDisplay.startX + 150 * ShieldDisplay.resFactorX and
                            x < ShieldDisplay.startX + 150 * ShieldDisplay.resFactorX + 65 * ShieldDisplay.resFactorX then
                            autoAdjustShield = not autoAdjustShield
                        end
                        -- Vent
                        if x > ShieldDisplay.startX + ShieldDisplay.resBarWidth + ShieldDisplay.textMargin * 2 and
                            x <
                            ShieldDisplay.startX + ShieldDisplay.resBarWidth + ShieldDisplay.textMargin * 2 +
                            80 * ShieldDisplay.resFactorX then
                            if not shield.isVenting() and shield.getShieldHitpoints() < shield.getMaxShieldHitpoints() then
                                local started = shield.startVenting()
                                if started then
                                    unit.stopTimer("dps")
                                    dpmTable = {}
                                    counter = 1
                                    dps = "Calculating"
                                    ttZ = 0
                                    ttZString = "Calculating"
                                    calculating = false
                                end
                            else
                                shield.stopVenting()
                            end
                        end
                    end

                    local used = ShieldRes[1][1] + ShieldRes[2][1] + ShieldRes[3][1] + ShieldRes[4][1]

                    if math.floor(ShieldRes.maxPool * 100) == math.floor(used * 100) then ShieldRes.currentPool = 0 else
                        ShieldRes.currentPool = ShieldRes.maxPool - used
                    end
                end